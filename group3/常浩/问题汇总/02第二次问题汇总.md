#### 三组问题汇总
* 1. bind怎么使用。
> bind的作用是在创建的时候改变其this指向，并固定参数，调用的时候传的参数向后顺延，返回值是一个新的函数
```javascript
    // 1. 具名函数bind用法 :

      function foo(){}

      var newFoo = foo.bind();

      // 2. 匿名函数bind用法

      var foo = function(){

      }.bind() 
```
* 2. bind封装的柯里化;
> 柯里化：函数嵌套函数，内部函数帮忙调用目标函数
> bind 封装使用了柯里化
```javascript
      function myBind( fn , _this ){
            return function(){
                  fn.call(_this)
            }
      }
```
* 3. offsetLeft , offsetTop,   事件对象 e.clientX; e.clintY, e.offsetX,e.offsetY, e.screenX,e.pageY;  的区别

> offsetLeft , offsetTop 获取元素距离可视区域的left值和top值; 是否有存在position属性的父级;
> client 可视区到鼠标点的x轴距离。
> offset 事件源到鼠标点的x轴距离。
> screen 屏幕到鼠标点x轴距离。
> page   文档到鼠标点x轴距离。
* 4. Object ,新方法 设置的时候，如果属性多的话，难到要一个个设置吗？ 有没有简写什么的？

```javascript
      Object.defineProperties( {
            "a":{
                  get : function(){},
                  set : function(){}
            },
            "b":{

            }
      } )
```
* 5.  todolist事件委托的事件类型为change，这样input里面内容不变时，就不能触发函数了，怎么解决

* 给 input 绑定独立的事件;

```javascript
    todolist高级封装里面的这段代码看不懂
     // 判定是否存在子集;
     // 利用短路运算节省性能 , 如果没有传递 domJson.children 属性，那么我们直接跳出for循环不进行其他判断操作;
     // domJson.children && (childNode = domJson.children[i++]);
      for(var i = 0 , childNode ; domJson.children && (childNode = domJson.children[i++]);){
            // childNode => 子节点;
            // 函数的使用者定义的参数; 
            // 1. 元素节点; => 直接插入父级
            // 2. 结构对象; => 创建成元素 再插入父级;
            childNode.nodeType === 1 ? ele.appendChild(childNode) : ele.appendChild( createElement(childNode) )
      }
      return ele ;
}
```
* 6. .toString为什么能实现数组只有字符串的扁平化.
> 因为数组在调用 toString 的过程中,会忽略数组的结构,把所有的数据以 `,` 为间隔拼接成一个字符串;
> var arr = [1,[2,3,4,5],6];
> arr.toString().split(",");

* 7. 浅拷贝和深拷贝的区别.
> 浅拷贝是引用传递  拷贝的是地址 ；
> 深拷贝是两个一模一样的数组、对象  但是他们是不相等的   是一个新的对象或者数组，地址是不同的。
> 伪深浅拷贝： 最外层的是不同的地址  但是内部数组、对象的地址还是一样的   和深拷贝的不能  深拷贝的从内到外都是不同的地址！
```javascript
  // 我已经有了一个对象了 , 我想要克隆出来一个;
            // var obj = {
            //       a : 10,
            //       b : 20
            // };

            // var cloneObj = obj;
            // 引用传递  <= 浅克隆;
            // 让obj 和cloneObj 一模一样; 
            // 最简单的深克隆 ; 
            // * 变量之中的存储的地址不同,内部属性,属性值都是完全一致的这种叫做深克隆。
            // var cloneObj = {};
            // // for 克隆 ; 
            // for(var attr in obj){
            //       cloneObj[attr] = obj[attr];
            // }
            // console.log(cloneObj);


            // 复杂形势的克隆;
            var obj = {
                  a : 10,
                  b : [],
                  c : {
                        d : 1,
                        e : {},
                        f : []
                  }
            }
            // 克隆 内部存在引用类型的对象;
            // var cloneObj = {};

            // for(var attr in obj){
            //       cloneObj[attr] = obj[attr];
            // }
            // console.log(cloneObj); //伪深克隆

            // 一行代码完美深克隆;  推荐使用;
            
            // var cloneObj = JSON.stringify(obj);
            //     cloneObj = JSON.parse(cloneObj);
            // console.log(cloneObj);

            // 递归 ;

            // var obj = {
            //       a : 10,
            //       b : [],
            //       c : {
            //             d : 1,
            //             e : {},
            //             f : []
            //       }
            // }

            // function clone(obj){
            //       var newo = {};
            //       for(var attr in obj){
            //             if(typeof obj[attr] === "object"){
            //                   // console.log(attr,obj[attr]);
            //                   // 给新的对象复制 [ 目标对象的属性 ] = 目标对象的这个属性是否为数组 ? 转换成字符串变成新数组 : 重新创建一个对象 ; 
            //                   newo[attr] = obj[attr] instanceof Array ?  obj[attr].toString().split(",") : clone(obj[attr]);
            //             }else{
            //                   newo[attr] = obj[attr];
            //             }
            //       }
            //       return newo;
            // }
            // var cloneObj = clone(obj);
            // console.log(cloneObj);

            // 对象合并方法 => ES6 ; Object.assign;  jQuery => $.extend();

            // 合并目标;
            // var obj = { a : 1 , c : []};
            // var obj2 = { b : 2};
            
            // 合并结果;
            // var obj3 = Object.assign( obj , obj2 );
            // var obj3 = Object.assign( 目标 , 向前合并, 向前合并 ,.... );
            // console.log(obj3,obj,obj2);

            // 表层不用for循环的深克隆;  => 只能有一层;
            // var cloneObj = Object.assign( {} , obj);
            // console.log(cloneObj);

            // 浅克隆 :  克隆地址 | 引用传递;
            // 深克隆 :  1. 创建全新的引用类型;
            //           2. 根据源类型进行赋值;

            // 1. var cloneObj = JSON.parse(JSON.stringify(obj))
            // 2. var cloneObj = 递归(obj);
            // 3. Object.assign({},对象); 

            //* 函数的拷贝;
            function foo(){
                  console.log("hello")
            }     

            // var cloneFoo = foo;
            var cloneFoo = eval("(" + foo.toString() + ")");
            console.log(cloneFoo);
```
* 8. 正则表达式什么时候用小括号，什么时候用中括号？
> () 组;       => 需要获取到匹配字符;
> [] 元字符;   => 匹配多个或的时候使用元字符; 
> 知道他们的作用了 可以根据情况判定使用什么

#### 四组问题
* 1. **柯里化和闭包有什么区别和联系？**
> 柯里化为什么存在 ？ 创建时改变函数特征(参数,this指向);
> 闭包            ？ 1. 延长变量声明周期 2. 保密
> 区别 : 在于最终目的和编程导向。
> 联系 : 柯里化使用闭包机制。
* 2. ![Q1](https://www.xyhthink.com/img/0628.png) 为什么倒数第二行obj1里面c是3

> 其首先要明白Object.assign()的使用方法  实际是把第一个对象作为被添加的对象  然后把第二个对象添加到里面  
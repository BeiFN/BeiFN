1.bind怎么使用。

```javascript
      // 1. 具名函数bind用法 :

      function foo(){}

      var newFoo = foo.bind();

      // 2. 匿名函数bind用法

      var foo = function(){

      }.bind()

```

2.拖拽里面的柯里化再讲一遍。

* bind封装的柯里化;
* 函数嵌套，函数调用函数。
```javascript
      function myBind( fn , _this ){
            return function(){
                  fn.call(_this)
            }
      }
```

3.https://github.com/embaobao/webstudy/tree/master/2019.6.24._2.js.EventBubble/work-favoriteMuse
为什么移动回放的时候 没有回到原来的位置？

* 第一次记录位置时，元素位置已经发生改变。因为记录的地点在move事件之中。

4.toString为什么能实现数组只有字符串的扁平化.
> 扁平化的骚操作;
> var arr = [1,[2,3,4,5],6];
> arr.toString().split(",");

* 因为数组在调用 toString 的过程中,会忽略数组的结构,把所有的数据以 `,` 为间隔拼接成一个字符串;

5.表单验证事件处理函数为什么要用bind.

* 因为要传递参数 

6.正则表达式什么时候用小括号，什么时候用中括号？

* () 组;       => 需要获取到匹配字符;
* [] 元字符;   => 匹配多个或的时候使用元字符; 

7.浅拷贝和深拷贝的区别.

* 见问题汇总文件夹下0628文件夹；

8. offsetLeft , offsetTop,   事件对象 e.clientX; e.clintY, e.offsetX,e.offsetY, e.screenX,e.pageY;
   
* offsetLeft , offsetTop 获取元素距离可视区域的left值和top值; 是否有存在position属性的父级;
* client 可视区到鼠标点的x轴距离。
* offset 事件源到鼠标点的x轴距离。
* screen 屏幕到鼠标点x轴距离。
* page   文档到鼠标点x轴距离。

9. 事件委托封装时候 在执行循环之前判断点击了父元素，是否会有优化？
   ![img.png](https://upload-images.jianshu.io/upload_images/15342731-18eb18d581aadfa8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* 减少循环执行次数性能一定优化，优化逻辑提前去根据需求定制。

10.  Object ,新方法 设置的时候，如果属性多的话，难到要一个个设置吗？ 有没有简写什么的？

```javascript
      Object.defineProperties( {
            "a":{
                  get : function(){},
                  set : function(){}
            },
            "b":{

            }
      } )
```

11.  计时器如果作为独立的异步方法 ，那他是怎么访问到函数中的局部变量的？过程不太清楚

```javascript
      function foo(){
            var a = 10;
            setInterval(function(){
                  console.log(a);
            },20)
      }

      var a = 10;
      setInterval(function(){
            console.log(a);
      },20)
```
12.  Object ,中的this 指向，说过后，还是不太清楚。

* this指向当前属性所属的obj;

13.  todolist事件委托的事件类型为change，这样input里面内容不变时，就不能触发函数了，怎么解决

* 给 input 绑定独立的事件;

```javascript
    todolist高级封装里面的这段代码看不懂
     // 判定是否存在子集;
     // 利用短路运算节省性能 , 如果没有传递 domJson.children 属性，那么我们直接跳出for循环不进行其他判断操作;
     // domJson.children && (childNode = domJson.children[i++]);
      for(var i = 0 , childNode ; domJson.children && (childNode = domJson.children[i++]);){
            // childNode => 子节点;
            // 函数的使用者定义的参数; 
            // 1. 元素节点; => 直接插入父级
            // 2. 结构对象; => 创建成元素 再插入父级;
            childNode.nodeType === 1 ? ele.appendChild(childNode) : ele.appendChild( createElement(childNode) )
      }
      return ele ;
}
```
#14.toString为什么能实现数组只有字符串的扁平化.
> 扁平化的骚操作;
> var arr = [1,[2,3,4,5],6];
> arr.toString().split(",");

* 因为数组在调用 toString 的过程中,会忽略数组的结构,把所有的数据以 `,` 为间隔拼接成一个字符串;

#15.浅拷贝和深拷贝的区别.

* 对象的深浅拷贝。
* 深拷贝
* 浅拷贝
#16.表单验证事件处理函数为什么要用bind.

* 因为要传递参数 

#17.正则表达式什么时候用小括号，什么时候用中括号？

* () 组;       => 需要获取到匹配字符;
* [] 元字符;   => 匹配多个或的时候使用元字符; 
#18.轮播图下方数字按钮切换不会做。
见案例
#19.智哥，能再捋一下构造函数，原型和实例之间的关系吗？
* 捋过了,见一组;

#20.烟花爆炸函数里面在for循环里面烟花移动，烟花是一个一个移动，因为for循环速度太快，所以才看上去是一起移动的吗？

* 异步 :
```javascript
  for(var i = 0 ; i < 10 ; i++){
      setInterval(function(){
            console.log(1)
      },200)
  }
```
for => 执行结束 => 异步队列之中的内容 => 200ms之后执行 => 回调函数;

同步循环执行结束之后再去执行move方法 => 所以看起来move方法是同时执行的(烟花同时运动);

#21.智哥，可以再讲一遍烟花吗？

* 提出具体的点;
#22.智哥，能再捋一下代码吗?  
#23.智哥,能再讲一下分页器之后的吗?

* banner

- **构造函数**统筹全局,作为整个程序的开始; 
      1. 接受参数;
      2. 初始各种dom对象，变量...,调用核心方法;.
-  初始化功能(init) 
      * 处理耦合关系。 调用各个方法;
      1. 调用;
      2. 事件;
-  初始布局
      1. layoutAnimate 
       因为布局本身分成两种，一种是position所有slide集中在一起的布局。另外一种是大长条布局。
            - this.options.effect 核心逻辑;
            1. slide => 大长条布局;
            2. fade  => 集中布局
            tip : switch 的使用是因为当前程序可以具备相当优秀的扩展性。
      2. layoutPagnination 
       创建页面分页器小按钮的功能。
            - 分页器是否存在 , 存在继续创建，不存在就停止;
            - 根据需求拼接分页器字符串,放入对应的位置;
-  控制下标 
      * this.nowIndex 
      * this.state 
            1. normal      => 正常情况;
            2. changeLast  => 从第一张切换到最后一张;
            3. changeFirst => 从最后一张切换到第一张;
            4. changePage  => 在最后一张假的第一张图片调用toIndex方法实现特殊bug解决
      1. prevIndex
            本身是一个循环变量的逻辑,因为slide动画需求,所以在prevIndex里面创建一个state属性用来记录特殊值;
            * this.state => changeLast
      2. nextIndex
            同上
      3. toIndex
            同上;
-  控制动画
      * fade      
            清空其余效果，给this.nowIndex元素增加效果;
      * slide
            this.nowIndex 
            1. changePage : 解决bug;
            2. normal     : 根据this.nowIndex 改变left值;
            3. changeFirst: 先挪过去,再动画;
            4. changeLast : 同上;
- 控制分页器按钮显示
      * handlerPaginationClick
            点击按钮的下标记录;
      * changePagination
            根据 this.nowIndex 结合 this.options.effect 判定应该如何显示;
#24.这里两个函数分别改变了this指向，为什么最终指向的是实例？
![image.png](https://upload-images.jianshu.io/upload_images/18442274-cfdbcb792366c2c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* 因为在使用bind方法时，这时候会创建一个新函数 ， 并且将传入函数的this固定。因所能操作的函数，都不再是原函数了，而是包裹着原函数的调用的匿名函数。
```javascript
      function bind(callback,_this){
            return function(){      
                  callback.call(_this);
            }  
      }
```

![image.png](https://upload-images.jianshu.io/upload_images/18442274-763af1f8f15ecb84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#25.这两种方式都可以让变量有初始值，哪种更好呢？
![image.png](https://upload-images.jianshu.io/upload_images/18464133-2583b5911d7b91ff.jpg?imageMogr2/auto-orient/)

```javascript

      function foo( hello = "hello" ){
            console.log(hello)
      }

      function foo( hello = "hello" , { a = 1 , b = 2 , c = 3 } = {}){
            console.log(hello , a , b ,c, )
      }
      foo("world");

```

* 这两种默认值方式没有严格意义的好坏之分，只有使用场景的不同选择不同而已。
* 在函数内部使用变量时，这个时候两种方式没有区别。 区别在于传递实参的时候存在差别。
* 对象传参可以做到想要传递什么参数就传递什么参数，其余的参数可以不传。



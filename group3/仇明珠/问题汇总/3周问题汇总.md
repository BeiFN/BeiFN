1.bind怎么使用
解决:
```javascript
    //具名函数bind用法
    function foo(){}
    var newFoo=foo.bind();
    var foo=function(){}.bind();
```
2.bind封装的柯里化
解决:
```juavascript
    function myBind(fn,_this){
        return function(){
            fn.call(_this);
        }
    }
```
3.拖拽回放的时候，为什么没有回到原来的位置
解决:
第一次记录位置时，元素位置已经发生改变。因为记录的地点在move事件之中
4.offsetLeft,offsetTOP,事件对象e.clientX,e.clientY,e.screenX,e.pageX
解决:
offsetLeft,offsetTop 获取元素距离可视区域的left值和top值;是否有存在position属性的父级
client 可视区到鼠标点的x轴距离
offset 事件源到鼠标点的x轴距离
screen 屏幕到鼠标点的x轴距离
page 文档到鼠标点x轴距离
5.事件委托封装的时候 在执行循环之前判断点击了父元素，是否会有优化
解决:
减少循环执行次数性能一定能优化，优化逻辑提前去根据需求定制
6.Object新方法设置的时候。如果属性多的话，难道要一个个去设置吗？有没有简写什么的
解决:
```javascript
    Object.defineProperties({
        "a":{
             get:function(){},
             set:function(){}
        },
        "b":{
            get:function(){},
            set:function(){}
        }})
```
7.计时器如果作为独立的异步方法，那他是怎么访问到函数中的局部变量的
解决:
```javascript
    function foo(){
        var a=10;
        setInterval(function(){
            console.log(a);
        },20)
    }//形成了闭包，不会被垃圾回收机制回收
    var a=10;
    setInterval(function(){
        console.log(a);
    },20)
```
8.Object中的this指向，说过后，还是不太清楚
解决:
this指向当前属性所属的obj
8.todolist事件委托的事件类型为change，这样input里面的内容不变时，就不能触发函数了，怎么解决:
给input绑定独立的事件
9.todolist高级封装里面的这段代码看不懂
解决:
```javascript
    //判定是否存在子集
    //利用短路运算节省性能，如果没有传递domJson.chrldren属性，那我们直接跳出for循环不进行其他判断操作
    for(var i=0,childNode;domJson.children&&childNode=domJson.children[i++]){
        //childNode=>子节点
        //函数的使用者定义的参数
        //1.元素节点=>直接插入父级
        //2.结构对象=>创建成元素 再插入父级
        childNode.nodeType===1?ele.appendChild( childNode):ele.appendChild(createEle(childNode));
        return ele;
```
10.toString为什么能实现数组只有字符串的扁平化
解决:
```javascript
    //扁平化骚操作
    var arr=[1,[2,3,4,5],6];
    arr.toString().split(",");
```
因为数组在调用toString的过程中，会忽略数组结构，把所有数据以","为间隔拼接成一个字符串
11.浅拷贝和深拷贝的区别
解决:
### 对象的深浅拷贝
浅克隆:克隆地址 | 引用传递
深克隆:1.创建全新的引用类型
         2.根据源类型进行赋值
（现在只针对于我们构造出来的对象和数组）
```javascript
    var obj={
        a:10，
        b:20,
    };
    var cloneObj=obj;
    //引用传递<=浅克隆
    //让obj和cloneObj一模一样
```
```javascript
//最简单的深克隆
*变量之中的存储的地址不同，内部属性，属性值都是完全一致的这种叫做深克隆
     var obj={
        a:10，
        b:20,
    };
    var cloneObj={};
    //for克隆
    for(attr in obj){
        cloneObj[attr]=obj[attr]
    }
```
//复杂形势的克隆
```javascript
    var obj={
        a:10,
        b:[],
        c:{
            d:1,
            e:{},
            f:{},
        }
    }
    //克隆 内部存在引用类型的对象
    var cloneObj={};
    for(var arrt in obj){
        cloneObj[attr]=obj[attr];
        console.log(cloneObj===obj)//此时为flase
       console.log(cloneObj.b===obj.b)//此时为true
    //所以不能用这种方式进行深克隆
    }
```
//一行代码完美深克隆(推荐使用)
```javascript
    var obj={
        a:10,
        b:[],
        c:{
            d:1,
            e:{},
            f:{},
        }
    }
    var cloneObj=JSON.stringfy(obj);
    cloneObj=JSON.parse(cloneObj);
```
//递归
```javascript
    function clone(obj){
        var newo={};
        for(var attr in obj){
            if(typeof obj[attr]==="object"){
                newo[attr]=obj[attr] instanceof Array?obj[attr].toString().split(","):clone(obj[attr])else{
                    newo[attr]=obj[attr];
                }
            }
            return newo;
        }
        
    }
```
### 对象合并方法
ES6提供=>Object.assign
jQuery=>$.extend();
```javascript
    var obj={a:1,c:[]};
    var obj2={b:2};
    var obj3=Object.assign(obj1,obj2);
    console.log(obj1===obj3)//此时为true
```
//利用对象合并的深克隆=>只有一层，内部不能再有引用类型
```javascript
    var cloneObj=Object.assign({},obj);
```
#### 深克隆总结
1.
```javascript
    var cloneObj=JSON.parse(JSON.stringfy(obj))
```
2.
```javascript
    var cloneObj=递归(obj)
    //
```
3.
```javascript
    Object.assign({},对象);
```
### 函数拷贝
```javascript
    function foo(){
        console.log("hello")
    }
    var cloneFoo=eval("("+foo.toString()+")");
```



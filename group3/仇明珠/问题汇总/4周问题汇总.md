1.构造函数、原型、实例之间的关系
解决:
构造函数和实例对象之间的关系 创造
```javascript
    var instance=new Foo();
    //   实例         构造函数
```
原型对象和实例的关系 指向
```javascript
    Foo.prototype=>用来储存数据,储存方法的地方
    var instance = new Foo();
    instance =>{
        constructor:Foo,//构造函数指针
        __proto__:Foo.prototype//构造函数原型指针
    }
``` 
所有的方法都放在原型之中
实例就可以共享所有的方法了
```javascript
    {
        constructor:Foo,
        __proto__:Foo.prototype
    }
    Foo{}.a
    //1.在 实例对象 Foo{}里面查看是否存在a属性，如果存在返回结果，如果不存在沿着__proto__去进行找寻
    //2.Foo.prototype 里面查看是否存在a的属性，同上
    //3.Object.prototype里面查看是否存放 a 的属性
```
2.烟花爆炸函数里面在for循环里面烟花移动，烟花是一个一个移动，因为for循环速度太快，所以才看上去是一起移动的吗
解决:
```javascript
    for(var i=0;i<10;i++){
        setInterval(function(){
            console.log(1);
        },200)
    }
```    
for=>执行结束=>异步队列之中的内容=>200ms之后执行=>回调函数
同步循环执行结束之后再去执行move方法=>所以看起来move方法是同时执行的(烟花同时运动)
3.banner代码捋一下
解决:
构造函数统筹全局,作为整个程序的开始; 1. 接受参数; 2. 初始各种dom对象，变量...,调用核心方法;.
初始化功能(init)
处理耦合关系。 调用各个方法;
调用;
事件;
初始布局
layoutAnimate 因为布局本身分成两种，一种是position所有slide集中在一起的布局。另外一种是大长条布局。
this.options.effect 核心逻辑;
slide => 大长条布局;
fade => 集中布局 tip : switch 的使用是因为当前程序可以具备相当优秀的扩展性。
layoutPagnination 创建页面分页器小按钮的功能。
分页器是否存在 , 存在继续创建，不存在就停止;
根据需求拼接分页器字符串,放入对应的位置;
控制下标
this.nowIndex
this.state 1. normal => 正常情况; 2. changeLast => 从第一张切换到最后一张; 3. changeFirst => 从最后一张切换到第一张; 4. changePage => 在最后一张假的第一张图片调用toIndex方法实现特殊bug解决
prevIndex 本身是一个循环变量的逻辑,因为slide动画需求,所以在prevIndex里面创建一个state属性用来记录特殊值;
this.state => changeLast
nextIndex 同上
toIndex 同上;
控制动画
fade
清空其余效果，给this.nowIndex元素增加效果;
slide this.nowIndex 1. changePage : 解决bug; 2. normal : 根据this.nowIndex 改变left值; 3. changeFirst: 先挪过去,再动画; 4. changeLast : 同上;
控制分页器按钮显示 * handlerPaginationClick 点击按钮的下标记录; * changePagination 根据 this.nowIndex 结合 this.options.effect 判定应该如何显示;
评论 ( 0 )
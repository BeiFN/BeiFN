<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>事件委托</title>
    <style>
        *{margin: 0;padding: 0;}
        html,body{width: 100%;height: 100%;}
        li{list-style: none;
            text-align: center;
            background: yellowgreen;
            margin-top: 3px;
            
        }
        ul{
            padding: 0 100px;
            background: rgba(0, 0, 0, 0.2);
            height: 100%;
        }
    </style>
</head>

<body>
    <ul id="fuli">
        <li>这是li</li>
        <li>这是li</li>
        <li>这是li</li>
        <li>这是li</li>
        <li>这是li</li>
        <li>这是li</li>
        <li>这是li</li>
        <li>这是li</li>
        <li>这是li</li>
        <li>这是li</li>
        <li>这是li</li>
        <li>这是li</li>
        <li>这是li</li>
        <li>这是li</li>
        <li>这是li</li>
        <li>这是li</li>
        <li>这是li</li>
        <li>这是li</li>
        <li>这是li</li>
        <li>这是li</li>
        <li>这是li</li>
        <li>这是li</li>
    </ul>
    <script>
        //封装判断
        var fuli = document.getElementById("fuli")
        //这样就是直接执行delegation函数 返回的是里面的匿名函数 事件调用的就是匿名函数
        fuli.addEventListener = ("click",delegation(handlerEvent,"LI"));
        //把事件处理函数传过来调用   
        function delegation(handlerEvent,selector){
            //匿名函数中进行判断操作  
            return function(evt){
                var e = evt||event;
                var target = e.target||e.srcElement;
                if(target.nodeName ==selector){
                    //call将函数的this执行改为target  call在调用时改变this 第二个参数之后的与函数的形参一一对应
                    handlerEvent.call(target)
                }
            }
        }

        function handlerEvent(){
            this.style.backgroundColor = "yellowgreen";
            this.style.border = "1px solie white";
        }
    </script>
</body>
</html>
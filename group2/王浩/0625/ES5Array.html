<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        //forEach 遍历数组
        //语法：arr.forEach(callback[,thisArg])
        //参数：1.callback是数组中每个元素执行的函数，该函数会接收三个参数：currentValue、index（可选，当前元素的索引）、array（可选，forEach方法正在操作的数组）；2.thisArg（可选，当执行回调函数时用作this的值）
        //返回值：undefined
        //注：forEach 会接受一个函数作为参数,并在方法内调用 *参数函数* 数组项数次;
        
        // var arr = [1,2,3,4,5];
        // arr.forEach(function(ele,index,array){
        //     console.log(ele,index,array);
        // });

        //myForEach的封装
        // function myForEach(arr , fn){
        //     for(var i=0;i<arr.length;i++){
        //         fn(arr[i],i,arr);
        //     }
        // }
        // myForEach( [1,2] , function( item , index , arr){ 
        //     console.log(item , index , arr);
        // })


        //map 返回一个新数组，新数组之中装的是参数函数的返回值
        //语法：var new_array = arr.map(function callback(currentValue[, index[, array]]) {}[, thisArg])
        //参数：1.callback生成新数组元素的函数，使用三个参数：currentValue、index（可选，数组中正在执行当前元素的索引）、array（可选，方法被调用的数组）2.thisArg执行callback函数时使用的this值
    
        // var arr = [ 100,200,300,400,500 ];
        // var map1=arr.map(x=>x/10);
        // console.log(map1);
        // var newArray=arr.map(function(item,index){
        //     return item*1.3;
        // })
        // console.log (newArray);
        // console.log (arr.map(item=>item*1.3));

        //map的封装
        // function myMap(arr,fn){
        //     var array=[];
        //     for(var i=0;i<arr.length;i++){
        //         array.push(fn(arr[i],i,arr));
        //     }
        //     return array;
        // }

        // console.log(myMap(arr,item=>item*3));


        //filter  返回新数组,filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。
        //语法：var newArray = arr.filter(callback(element[, index[, array]])[, thisArg])
        //参数：1.callback 用来测试数组的每个元素的函数。返回 true 表示该元素通过测试，保留该元素，false 则不保留。它接受以下三个参数：element（数组中当前正在处理的元素）、index（可选正在处理的元素在数组中的索引）、array（可选调用了 filter 的数组本身）。2.thisArg可选执行 callback 时，用于 this 的值。

        // var arr=[10,20,30,40];
        // var filter1=arr.filter(item=>item>20);
        // console.log(filter1);
        // var newArr=arr.filter(function(item,index){
        //     return item>20;
        // })
        // console.log(newArr);

        //filter的封装
        // function myFilter(arr,fn){
        //     var array=[];
        //     for(var i=0;i<arr.length;i++){
        //         if(fn(arr[i],i,arr)){
        //             array.push(arr[i]);
        //         }
        //     }
        //     return array;
        // }

        // console.log(myFilter(arr,item=>item>30));


        //some() 方法测试是否至少有一个元素可以通过被提供的函数方法。该方法返回一个Boolean类型的值。(判定数组中是否存在某个符合条件的; 一旦函数返回true那么some就会终止循环，并且返回true)
        //注意：对于空数组上的任何条件，此方法返回false。
        //语法：arr.some(callback(element[, index[, array]])[, thisArg])
        //参数：1.callback用来测试每个元素的函数，接受三个参数：element（数组中正在处理的元素）、index （可选数组中正在处理的元素的索引值）、array（可选，some()被调用的数组）2.thisArg可选执行 callback 时使用的 this 值。
        
        // var eve=function (element){
        //     return element%2===0;
        // };
        // console.log(arr.some(eve));
        //some的封装
        // function mySome(arr, fn){
        //     var flag=[];
        //     for(var i=0;i<arr.length;i++){
        //         if(fn(arr[i])){
        //             flag.push(arr[i]);
        //         }
        //     }
        //     console.log(flag);
        //     if(flag.length===0){
        //         return false;
        //     }else return true;
        // }
        // function mySome(arr, fn){
        //     for(var i=0;i<arr.length;i++){
        //         if(fn(arr[i])){
        //             return true;
        //         }
        //     }
        //     return false;
        // }
        // console.log(mySome(arr,function(ele){
        //     return ele>16;
        // }))

        //every的封装
        // function myEvery(arr, fn){
        //     for(var i=0;i<arr.length;i++){
        //         if(!fn(arr[i])){
        //             return false;
        //         }
        //     }
        //     return true;
        // }
        // console.log(myEvery(arr,function(ele){
        //     return ele>13;
        // }))


        //reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值
        //接收的四个参数：Accumulator (acc) (累计器)、Current Value (cur) (当前值)、Current Index (idx) (当前索引)、Source Array (src) (源数组)您的 reducer 函数的返回值分配给累计器，该返回值在数组的每个迭代中被记住，并最后成为最终的单个结果值。
        //语法：arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])
        //参数：callback执行数组中每个值的函数，包含四个参数：accumulator累计器累计回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue（见于下方）。currentValue数组中正在处理的元素。currentIndex可选数组中正在处理的当前元素的索引。 如果提供了initialValue，则起始索引号为0，否则为1。array可选调用reduce()的数组initialValue可选作为第一次调用 callback函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。
        // var arr=[12,13,14,15];
        // var res=arr.reduce(function(pre,now,index,arr){
        //     console.log(pre,now,index);
        //     return pre+now;
        // })
        // console.log(res);


        //reduce的封装

        // function myReduce(arr,fn){
        //     var prev=arr[0];
        //     for(var i=1;i<arr.length;i++){
        //         prev=fn(prev,arr[i],i,arr);
        //     }
        //     return prev;
        // }
        // console.log(myReduce(arr,function(prev,now,index){
        //     return prev+now;
        // }))


        //数组扁平化的实现
        // var arr = [[1,2,3,4],[5,6,7,8]];
        // console.log(arr.flat());
        // console.log(arr[0].length)
        

        // function flat(arr){
        //     var res = [];
        //     for(var i = 0 ; i < arr.length ; i ++){
        //         if(!(arr[i] instanceof Array)){
        //                 res.push(arr[i])
        //         }else{
        //                 flat();
        //         }
        //     }
        //     return res ;
        // }

        // console.log(flat(arr))
        // function flat(arr){
            //       // 判定是否是第一次执行flat ;
            //       if(!flat.res){
            //             flat.res = [];
            //       }
            //       for(var i = 0 ; i < arr.length ; i ++){
            //             //只要不是数组我就push
            //             if(!(arr[i] instanceof Array)){
            //                   flat.res.push(arr[i])
            //             }else{
            //                   flat(arr[i]);
            //             }
            //       }                 
            //       return flat.res ;
            // }

            // // flat.a = 10;

            // console.log( flat(arr));
           
            // var arr = [
            //       [1,2,3,4,5],
            //       [2,3,4,5,7]
            // ]
            // var res = [];
            // var i = 0 ; 
            // while( true ){
            //     if(!(arr[i] instanceof Array)){
            //       res.push(arr[i])
            //     }else{
            //       var k = 0;
            //       while(true){
            //             if(!arr[i][k]){
            //                   break;
            //             }
            //             res.push(arr[i][k]);
            //             k++
            //       }
            //     }
            //     i++;
            //     if(arr[i] == undefined){
            //           break;
            //     }
            // }

    </script>
</body>
</html>
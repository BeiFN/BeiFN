<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        //正则的使用场景：一种字符串的匹配模式-如果没有正则，就需要遍历字符串，进行操作；
        /**正则的创建有两种方式：
            1)构造函数的方式：
            var reg = new RegExp("a" , "g");
            a “模式字符串” ：规则简写 + 量词
            g “修饰符”
            tip：在事先不确定的情景，动态生成规则时，必须使用构造函数；
            2)字面量的方式
            var pattern = /模式字符串/修饰符(flags); 
            字面量创建方式不能进行字符串的拼接，实例创建方式可以；
            字面量创建方式特殊含义的字符不需要转义，实例创建方式需要。
        */

        /**正则的构造组成
         * 规则：1.数字 2.字母 3.特殊符号 4.汉字...（ASCII码范围）
         * 修饰符：g 全局匹配 
         *        m 多行匹配
         *        i 不区分大小写
         *        y 可以匹配两个字符的汉字 es6
         * 量词：（元字符）
         *  \d  0-9之间的任何数字
         *  \w  数字，字母，下划线 0-9 a-z A-Z _
         *  \s  空格或者空白等
         *  \D  非\d
         *  \W  非\w
         *  \S  非\s
         *  .   除了\n以外的字符
         *  *   任意个
         *  +   一次或者多次
         *  ？  零次或一次 紧跟在*，+，？或{}的后面，会使量词变成非贪婪的
         *  ^   从开头匹配
         *  $   从结尾匹配
         *  |   或
         *  ()  分组匹配
                凡是|出现的时候，一定要注意是否要加()来提高优先级
         *  []  选择匹配 [^]选择没有的匹配 [a-b]匹配a-b的任何一个
                []里不会出现两位数
         *  {}  匹配次数 {n} {n,} {n,m}
         *  (?:x)    非捕获括号
        */

        /**正则的方法
         * 1)   正则对象.test("匹配的字符串") true false
         * 2)   正则对象.exec("匹配的字符串")
         *      如果匹配返回一个数组(匹配数+出现位置+输入字符串)，反之为null
         *      tips：确保使用了"g" 不然下次exec将陷入死循环
         * 3)   字符串对象.match(正则表达式)
         *      返回所匹配的项，如果使用全局修饰符返回多个，不使用的话与exec方法相同
        */  

        /**懒惰与贪婪
         *  贪婪性：正则在捕获时，每一次会尽可能多的去捕获符合条件的内容。
         *      如果我们想尽可能的少的去捕获符合条件的字符串的话，可以再量词后面加?
         *  懒惰性：正则在成功捕获一次后不管后边的字符串有没有符合条件的都不再捕获。
         *      如果想捕获目标中所有符合条件的字符串的话，我们可以用修饰符g来全局捕获。
        */ 
    </script>
</body>
</html>
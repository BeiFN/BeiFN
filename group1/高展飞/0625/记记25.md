###事件的委托
    ***什么情况需要事件委托
    1.在需要绑定同一等级的子元素时，防止事件冗余。
    2.在create一个新元素时（动态生成的元素绑定事件）

###  ES5   ###
    ES5是目前公认的最稳定兼容的版本(IE8+)

增加了不少内容
    1.严格模式
    2.扩展了数组类型方法
    3.扩展了部分对象里的方法
    4.提供了新的对象  JSON;

##严格模式##
    "use strict"
    1.全局严格   2.局部严格
    提高了代码的规范，执行效率

    ①变量的严格
    
    ②参数的严格
    ③函数的严格
    ④*  一个语法的注意事项
###注意：：：：
    严格模式下变量必须先声明后再赋值
    形参被赋值不会影响到arguments里面的参数
    不允许使用arguments.callee
    注意分号及其他符号，该写必须写

###ES5数组方法##
    forEach , map , filter ,some , every ,reduce
#### *** forEach
    forEach 没有返回值，返回值为undefined
    forEach 是用来遍历数组的;
    forEach 会接受一个函数作为参数(该函数是实参)，并在方法内调用“参数函数”数组项数次; 在函数内调用形参 (帮助理解：forEach 的参数为函数,那么意味着forEach想要在 函数(forEach) 内部调用这个参数( foo );)  如：
```javascript
     var arr = [1,2,3,4,5,6,6,7,9];
        arr.forEach( foo )
        // foo (item , index , arr) ;
        function foo( item , index , arr){
              console.log(item , index , arr);    
        } 
```
#### *** map
    返回一个新数组，新数组之中装的是参数函数的返回值
```javascript
    var arr = [15000,20000,21000,26000,3000,2000,8000];
    var newArray = arr.map( function ( item , index ){
             return item * 1.3;
     })
```
###****filter  
    返回新数组，会根据参数函数返回值判定是否该将具体的项加入新数组
```javascript
    var arr = [15000,20000,21000,26000,3000,2000,8000];
        var newArray = arr.filter(function(item , index){
            return item >= 10000;
    } )

```
###****every
    跟some一样，但要求每一项都符合，才返回true
    有一项不合格就返回false
```javascript
//eg:判断数组中的数组是否都是偶数
     var arr = [15000,20000,21000,26000,3000,2000,8000];
        var boolean = arr.every(function( item , index , arr){
                return item % 2 === 0
    })
            console.log(boolean);
```
###****every
    跟过滤器好像差不多，但它只会返回一个布尔类型，如果匹配成功，则返回true
    而且一旦匹配成功，后面就不再遍历了，如果没有匹配成功，最后返回false
```javascript
//eg:判断数组中的数组中有没有 3000这一项
    var arr = [15000,20000,21000,26000,3000,2000,8000];
        var boolean = arr.some( function (item ,index , arr){
              console.log(item);
              return item === 3000
        })
    console.log(boolean);
```
###Object.defineProperty ();
    configurable :false;(默认)
    不可删除
    enumerable：false;
    不可枚举
    value
    writable
    get
    set

```javascript
     var obj = {
            $data : {};
        }
        Object.defineProperty( obj , "a" , {
            get : function(){
              return this.$data.a++;
            },
            set : function(val){
              return this.$data.a = val;
            }
        })   
        // console.log(obj);
        //如果直接给obj.a 赋值，而set中返回的是this.a 会导致一直调用set导致报错，解决方法是在obj内部创建一个对象$data  这样将a放在该对象内就解决了   重复调用问题
        obj.a = 1;

        //面试题  可以使用上述方法
        console.log(obj.a === 1 && obj.a ===2 && obj.a === 3 && obj.a === 4);


```
####补充：：：：：

this指向   目前判断
1.如果前边没有xxx.函数（）；那就是window调用
2.看函数是不是事件处理函数，是就永远指向事件绑定者
注意：函数嵌套函数，内部函数永远指向window（没有时间的情况下）
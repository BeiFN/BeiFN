###ES6  转 ES5
nodejs  + babel
###es6疑难杂症的解决方案
1.promise    2.async   await
###es6 语法糖   
让代码更加清爽，有bg


###关键字  let    const
let  声明的变量：

1有块级作用域
2不允许声明提升


**之前：  块级作用域  =》 函数作用域
let后：大括号作用域
###for循环会产生两个变量
大括号里可以访问到小括号里的变量
大括号作用域是小括号的子集 如下图所示：
https://upload-images.jianshu.io/upload_images/18473143-e6c4f2a3af7584aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240
###暂时性死区
在变量声明时，变量之前所有空间，不允许使用这个变量（使用会报错）
在局部作用域中使用变量也要注意，也存在暂时性死区，访问机制与正常js机制一样

2在同一作用域之中，不允许重复声明变量


const   在模块（对象）中使用   确保数据不被污染，

#解构赋值
剩余运算符   ...
对象赋值   let一个变量 ，取出对象中同名属性的值
eg:var obj= {a :2};
let{ a }  = {obj}
相当于  var a = obj.a;
console.log(a)   // 2


获取数组方法：
之前写法：
var concat = Array.prototype.concat;

es6:方便对实例之中的方法取值
let {slice , concat } = Array.prototype;
console.log(slice,concat)

改名机制：
let slice = 10;
{原有属性 ： 新变量名}
let{slice : mySlice ， concat} = Array.prototype;
console.log(mySlice)


1.基本结构： let {}  =  {}
2.基本使用：变量声明，属性赋值
let{a,b} = { a: 1 ,b : 2};
    声明变量 a b    并给变量赋值为 对象.a  和 对象.b
3.变量别名  给c变量赋值 对象.a 的属性值
4.带有默认参数的赋值：
let {a = 10 ,b=20} = { a: 30 ,b=40}
console.log(a,b) // 30 ,40

function Banner ( { a = 10 ,b= 20} = {}){
    console.log(a,b);// 40 20
}

Banner({
    a :40;//如果不传，则为默认值  10 20;
})
5.默认传参数
function Foo({effect = "fade" ,pagination = "pagination"}= {})
不需要传参时：Foo();
需要传参时：Foo({})
alert();  弹出警告框  只有确定按钮
comfirm(); 弹出警告框   有确定和 取消按钮
prompt(); 弹出警告框    有确定 和 取消按钮   并且可以输入反馈内容  
eval(); 将字符串转换成代码执行     JS解析器的调用装置  （js代码本质上都是字符串）   eval()中如果直接写“{}”，eval会只当是代码块，而不是对象，所以返回undefined。 加括号变成运算就好
放入json字符串，会报语法错误  （VM。。）在json外加上括号即可转为对象
close(); window下的方法  表示关闭当前页面
this = >指针是存在于执行环境之中的
建议this使用的地点在对象中，，，
this指向调用者
页面在初始化时，首先执行的是window的执行环境，window是一个永久的活动对象
有n多个事件时，this指向当前发生的事件元素
定时器中的this指向window

DOM  是一个复杂庞大消耗性能的很重要的对象
DOM的结构   document =>  源
html =>  根dom
增删改查 使用的选择器：
1原生提供的选择器 ；性能贼差

2.id选择器 性能最好的选择器
eg:getElementById();
3.jQuery => 高性能选择器
4.标签选择器 
eg：getElementsByTarName();
所有多个元素选择器，获取来的元素一定为伪数组
伪数组两个类型：
（HTMLCollection     NoneList  等级很高）

scrollTop和scrollLeft
二者存在兼容性问题
在FF(firefox)中 body的可以识别scrollTop  html.scrollTop =0;
用dom操作获取ff中的scrollTop  ：document.body.scrollTop;
在chrome中， html可以识别 scrollTop，但body .scrolltop=0;
用dom操作获取chrome中的scrollTop: document.documentElement.scrollTOP


查询操作：
id选择器  ；=>单个选择器
tag选择器
name选择器getElementsByName
class 选择器  性能极差 ，兼容性不好  兼容性IE8+以上   不建议使用  getElementsByClassName

query选择器    IE8+    性能好
document.querySelector();  选择单个元素使用
document.querySelectorAll(); 选择多个重复的元素
增加操作;
document.createElement(); 创建新的元素
父级元素.appendChild();
document.body.appendChild(); 向后插入
将创建的元素放入页面中
注：如果appendChild操作的元素已经存于页面之中，那么appendChild会删除页面上的元素，，，重新将元素插入页面
父级元素。insertBefore();
document.body.insertBefore(要插入元素，老的元素);  表示要在老元素前插入
如果要插入在所有元素最前边   可以借用
children属性代表  document.body里面的所有的子集元素

删：：：：
document.body.removeChild(box);
简化写法:
parentNode => 找到父节点
box.parentNode.removeChild(box);

语法升级后：
box.remove();

改(1.内容  2.属性);
1.内容：
box.innerHTML:把带标签的字符串直接放在页面上，会把字符串解析成标签。 如果从元素内获取内容，会连带该元素内的标签和内容一并取出。
box.innerText：会先把字符串转义，之后放在页面上，此时标签会出现在页面上，， 如果从元素内获取内容，只会获取内。
2.属性
三个操作属性的API: setAttribute();设置属性 getAttribute();获取属性 removeAttribute();移除属性
  

浏览器： 多线程  多进程
渲染进程;  html+css => 呈现效果；
加载进程： 图片加载，js代码加载，css代码加载，HTML代码加载
JS加载：

offset xxx   方法耗性能  获取宽高方法是取出测量后再放回，这样会让页面回流   获取的是整个盒模型的宽高
获取一张图片 img =>onload;
 img.onload = function(){
   console.log(img.offsetWidth)
 }

 多张图片使用 window.onload
 window.onload = function(){
       console.log(img.offsetWidth);
 }

获取css内部宽高的方法：
get.ComputedStyle();
img.onload = function(){
    console.log(getComputedStyle(img)["width"]);
}
 元素属性获取及设置
 dom.style.属性名 = "属性值"
 dom.style.marginLeft = "200px";
 特性 => 会覆盖之前的属性;
 dom.style.cssText = "";
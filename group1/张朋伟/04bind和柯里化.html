<!DOCTYPE html>
<html lang="en">
<head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="X-UA-Compatible" content="ie=edge">
      <title>Document</title>
</head>
<body>
      <script>
            //  bind   ;
            // 柯里化   ;

            // 改变函数this指向; 
            // bind  call apply;

            // bind  => 函数创建的时候,改变this的指向;
            // call  => 函数调用的时候改变this的指向;
            // apply => 函数调用的时候改变this的指向;
            
            // call 参数 => 形参对应;
            // apply 参数=> arugments;

            // 1. bind => 返回给你一个新函数;
            // 2. 新函数的this指向是固定的;

            // var foo = function(){

            // }.bind()

            // function foo(){
            //       console.log(this);
            // }           
            // var poo = foo.bind({});
            // // foo === poo;
            // poo();


            // function bind( fn , _this ){
            //       function newFn(){
            //             fn();
            //       }
            //       return newFn();
            // }

            // function foo(){
            //       console.log("hello world");
            // }

            // var poo = bind(foo)
            // poo();
            
            // 函数嵌套，在函数内部调用函数;
            // function bind( fn , _this ){
            //       function newFn(){
            //             fn.call(_this);
            //       }
            //       return newFn;
            // }
            // function foo(){
            //       console.log("hello world" , this);
            // }
            // var poo = bind(foo,{name : "吴彦祖"})
            // poo();
            // poo();

            // foo();

            // 柯里化参数处理;
            // function bind(fn,_this){
            //       // 在调用bind复制函数的时候 , 传入的参数;
            //       // 这个参数是用来固定函数的参数的;
            //       var args = [].slice.call(arguments).slice(2);
            //       // console.log(args);
            //       return function(){
            //             // 参数来源源自两个地方:
            //             // 1. bind在创建函数时绑定的参数;
            //             // 2. 匿名函数被调用时传入的参数;
            //             var nimingArg = [].slice.call(arguments);
            //             fn.apply(_this ,args.concat(nimingArg))
            //       }
            // }

            // function foo(a,b,c,d){
            //       console.log(a , b , c, d, this)
            // }
            // var poo = bind( foo , {name : "吴彦祖"} , 1 , 2  )
            // poo(3,4);
            // 1. this的绑定;
            // 2. 参数的处理; 拿出多余参数进行参数拼接，最后apply传入参数;
            
            // 完成bind方法的封装;
            // * 创建一个新函数;
            // 1. this 绑定;
            // 2. 强制定义参数;


            // 在函数内部返回一个函数,这个函数可以帮你调用参数函数;
            // bind到底是复制目标函数还是调用目标函数啊？ 调用 !!

            // 1. 创建一个函数返回一个新函数;

            // function bind(){
            //       return function(){

            //       }
            // }
            // var poo = bind();
            // function foo(){
            //       console.log(this);
            // }
            // foo();
            // function bind(fn , _this){
            //       return function(){
            //             fn.call(_this);
            //       }
            // }
            // var poo = bind(foo , {name:"吴彦祖"});
            // poo();
            
            // 参数;
            // 因为目标函数 使我们在bind封装内部调用的，所以我们可以对这个调用为所欲为。

            function foo(){
                  // console.log(arguments,this);
            }
            // foo();
            // function bind(fn , _this){
            //       var arg1 = [].slice.call(arguments).slice(2);
            //       // console.log(arg1);
            //       return function(){
            //             var arg2 = [].slice.call(arguments);
            //             console.log(arg2);
            //             // ["bind",1,2,3]    
            //             fn.apply(_this,arg1.concat(arg2));
            //       }
            // }
            // // 在bind的时候强制固定参数;
            // var poo = bind(foo , {name:"吴彦祖"} , "bind");
            // poo(1,2,3);
            // poo(1,2,3);
            // poo(1,2,3);
            // poo(1,2,3);
            // poo(1,2,3);

            // 预处理,自定义处理;
            

            function myEvent(fn){
                  return function(evt){
                        var e = evt || event;

                        fn({
                              clientX : e.clientX,
                              name:"myEvent",
                        });
                  }
            }

            document.addEventListener("click",myEvent(handlerClick) )
            function handlerClick(e){
                  console.log(e.clientX,e.name);
            }
      </script>
</body>    
</html>
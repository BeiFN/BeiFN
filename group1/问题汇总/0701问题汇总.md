# **06.25**

**小组成员： 陈荣强 张朋伟 陆凤妹  郑则栋 李红贵 李林 韩卫静 尹亚亭 李红霞  徐佳伟  刘彪  高展飞 李策  文君豪**

**组       长： 张朋伟**


## 问题1: 烟花程序中，Firework.prototype.fireworkBoom函数里的下段代码里的false不太理解，请智哥再讲解一下缘由。
![QQ截图20190702075026.png](https://upload-images.jianshu.io/upload_images/2845301-f40f51658e80023b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* bind(this,arg1)  => 生成一个新函数 => 包含了 fire_boom 元素的引用;
* 因此可以在运动结束后让元素进行删除。

##问题2  原型链的调用顺序没弄明白，请指教。

* 构造函数  
* 原型对象
* 实例对象

- 构造函数 和 原型对象之间的关系   伴生
  
  ```javascript
    function Foo(){}
    // 当一个函数出现的时候，JS会默认给他搭配一个原型对象;
    Foo.prototype
  ```

- 构造函数 和 实例对象之间的关系   创造  
  ```javascript 
    var instance  = new Foo();
    //   实例           构造函数;
  ```

- 原型对象和实例      指向
  ```javascript
    Foo.prototype => 用来储存数据,储存方法的地方

    var instace = new Foo();

    instance => {
        constructor : Foo ,         // 构造函数指针;
        __proto__   : Foo.prototype // 构造函数原型指针;
    }
  ```

* 最终目标 : 一套方法 可以重复使用,不需要多次声明。

* => 所有的方法都放在原型之中 ; 
*    实例就可以共享所有的方法了; 
*    有一个大的类别 : String | Array | Object | Number | Function | .....
*    [].forEach() 
*    所有的对象都有原型指针 => 因为所有的对象都来自构造函数;

* 面向对象编程 
* 需要一个对象 , {} × new Foo() √;
* Foo{} => 自定义实例对象 ;
```javascript
{
    constructor : Foo,
    __proto__ : Foo.prototype
}
Foo{}.a 

// 1. 在 实例对象 Foo{} 里面查看是否存在 a 属性 , 如果存在返回结果 ,如果不存在沿着 __proto__ 去进行找寻。
// 2. Foo.prototype 里面查看是否存在 a 的属性, 同上
// 3. Object.prototype 里面查看是否存放  a 的属性。

```

##问题3 智哥,可否再捋一捋烟花的代码?

* ok


##问题4  new*创造*新对象,赋值给table1 , table1为实例 , 怎么理解构造函数中的this指向实例 table1 , table1不是存的是地址!;

```javascript
    // 创建实例table1
    // 可以理解为 table1调用new Table();方法吗？
    var table1 = new Table("btn-list", "content-list");

    // 1.  构造函数创建实例;

    // 如何得到实例  : 
    // ① 构造函数的返回值;
    // ② 构造函数中的this;
```


##问题6 实例调用原型的init属性方法的流程是什么样的？原型是构造函数的原型，还是实例的原型？
* 实例 | this => 访问init => 实例中没有 => 沿着原型链向上找寻 => 找到原型上的init => 得到访问结果;

##问题7  如下注释的理解正确吗？ 请大家帮忙找出理解错误的地方。
```javascript
// 构造函数创建
        function Table(btnSe, contSe){
            // this是指向实例对象，使用Table构造的对象，即 Table{} ,
            // 给实例对象添加btns属性，存放所有目标元素
            this.btns = document.getElementById(btnSe).children;
            this.conts = document.getElementById(contSe).children;
        }
        // 原型添加方法属性, 初始化init, 实例调用初始化方法
        // table1.init(); table1调用了init方法，所以init方法里面this指向实例table1 √;
        Table.prototype.init = function(){
            // 从实例对象中获取目标元素添加绑定事件，并让this指向实例对象
            for(var i=0,btn; btn= this.btns[i];i++){

                // btn.addEventListener("click",this.handlerContent);
                // 面向对象编程中所有的函数内部this指向都指向实例对象 √;

                btn.addEventListener("click",this.handlerContent.bind(this,i));
                // 实例对象中的目标元素，调用原型的属性方法，并使用bind方法将指向btn的指针this指向实例

                btn.addEventListener("click",this.changeColor.bind(this,i));
            }
        }
        // 给原型对象添加事件处理方法属性，在绑定事件时固定了this指向，所以下方法中this指向实例table1
        Table.prototype.handlerContent = function(index,evt){
            var e = evt ||window.event;
            var target = e.target ||e.srcElement;
            for(var i=0,cont; cont = this.conts[i++];){
                cont.className = "";
            }
            this.conts[index].className = "active";

        }

        Table.prototype.changeColor = function(index,evt){
            var btn = this.btns[index];
            btn.style.backgroundColor = "#"+Math.round(parseInt("ffffff",16)*Math.random()).toString(16).padStart(6,"0");
        }

        //构 建函数方法使用
        // 创建实例table1

        //可以理解为 table1 调用new Table();方法吗？ × 
        // 你调用的 Table 不是table1;
        var table1 = new Table("btn-list", "content-list");
        table1.init();
```


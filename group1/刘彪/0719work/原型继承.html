<!DOCTYPE html>
<html lang="en">
<head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="X-UA-Compatible" content="ie=edge">
      <title>Document</title>
</head>
<body>
      <script>
            // function Father(){}
            // Father.prototype.show = function(){
            //       console.log("hello i'm class Father");
            // }
            
            // Father.prototype.hello = function(){
            //       console.log("i'm Father's hello");
            // }
            // function Son(){}
            // 一、克隆式继承; 别人有啥我就直接拿过来啥;
            // Son.prototype.show = Father.prototype.show;
            // Son.prototype = Father.prototype;
            // Son.prototype.hello = function(){
            //       console.log("hello");
            // }
            // console.log(new Son());            
            // // 继承时我们不污染父类 , 我们拷贝父类;
            // // 什么是原型继承 : 把别人家的方法名, 方法的引用拿到我自己的原型上。
            // 克隆 拷贝式继承 ; =>  for in 原型继承;
            // for(var attr in Father.prototype){
            //       // console.log(attr);                  // Father 上原型的属性;
            //       // console.log(Father.prototype[attr]);// Father 上的原型方法;
            //       Son.prototype[attr] = Father.prototype[attr];
            // }
            // console.log(new Son());

           

            // 二、寄生式继承;也是原型链继承;
            // 寄居蟹 : 不是我自己的，但是我获得了使用权。
            //  JS之中使用权怎么获得那 ? 原型链 ; 
            // function Father(){}
            // Father.prototype.show = function(){
            //       console.log("hello i'm class Father");
            // }
            // Father.prototype.hello = function(){
            //       console.log("i'm Father's hello");
            // }

            // function Son(){}
            //1. __proto__ 不兼容;
            // (1)保留Son的原型对象;
            // (2)给Son的原型对象重置 一个 原型指针;把this指向改为父级构造函数的原型对象;
            // Son.prototype.__proto__ = Father.prototype;

            //2.兼容性写法;
            //Son构造函数的原型对象设置为父级的实例对象;
            // Son.prototype = new Father();
            // 把constructor设置回来;
            // Son.prototype.constructor = Son;
            // console.log(new Son());

            // 这个写法太墨迹了 => 还得实例一下 Father 类;

            // 3、ES5 方法实现原型链继承;
            //(1)**创建**一个新对象; 
            //(2)把参数放入新对象的原型指针之中;
            // var obj = Object.create({name : "hello"});
            // console.log(obj.name);
            // Object.create => 
            // tip : 创建出来的新对象 , 原型指针指向参数对象。


           
            // function Father(){}
            // Father.prototype.show = function(){
            //       console.log("hello i'm class Father");
            // }
            // Father.prototype.hello = function(){
            //       console.log("i'm Father's hello");
            // }

            // function Son(){}
            // Son.prototype = Object.create(Father.prototype);
            // Son.prototype.constructor = Son;
            // console.log(new Son());
            // 可以通过Son实例访问到Father原型上的方法;

            // 原型链;
            // 构造函数 | 原型 | 实例;
            // 1. 构造函数和原型 => 伴生;  构造函数.prototype => 存储数据的对象;
            // 2. 实例 和 原型   => 原型指针 ; 实例对象里都包含一个原型指针 , 指向当前实例构造函数的原型;
            // 3. 实例 和构造函数 => 构造函数创建了实例;

            // JS的对象访问机制; 
            // 访问对象 (属性|方法) => 查找当前对象是否存在 = 存在 >  直接返回结果;
            //                                           =不存在>  原型链继续访问;
            // 原型也是对象 依照上述规则进行访问直到访问到Object的原型(顶级原型)仍无访问结果会返回undefined;


            // 原型链继承; => 拿到别人家的功能的使用权;
            // function Father(){}; 
            // Father.prototype.hello = function(){
            //       console.log("hello world");
            // }
            // // new Father().hello(); 
            // // 构造函数 Father 的实例对象可以访问到原型对象之中的方法;

            // function Son(){}
            // Son.prototype.__proto__ = Father.prototype;
            // new Son().hello();
            // 寻找hello函数的路径
            // Son{} ? => Son.prototype => Father.prototype 有 return ;
            // 得到了 Father原型的访问权限;
            // Son.prototype = Object.create(Father.prototype);

            
      </script>
</body>
</html>
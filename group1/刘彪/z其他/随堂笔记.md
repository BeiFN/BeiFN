
#事件类型

##1.鼠标事件
onclick         鼠标单击
ondblclick      鼠标双击
onmousedown     鼠标按下
onmousedup      鼠标抬起
onmouseover     鼠标移入
onmouseout      鼠标移出
onmousemove     鼠标移动
onmousenter     鼠标划入（区别于onmouseover）
onmouseleave    鼠标划出（区别于onmouseout）

##2.键盘事件
onkeydown       键盘按下
onkeyup         按键抬起
onkeypress      按一下键盘

##3.元素事件
onfocus         获取焦点
onblur          失去焦点
oninput         正在输入
onchange        已经改变
onsubmit        表单提交

##4.窗口事件
window          窗口的统一入口
window.onload   加载结束
window.onresize 窗口尺寸改变
window.onscroll 滚动条发生滚动





#1.输出相关
alert()                   弹出警告框
confirm()                 弹出警告框（带有确认取消），返回布尔值
prompt("提示内容")         弹出警告框，可输入内容
console.log()             控制台输出
document.write()          页面输出    
document.writeln()        页面输入(连续输出中间有空格)



#2.Math相关
Math.pow(i,j)             i的j次方
Math.random()             随机取[0,1)的数
Math.round()              对小数四舍五入
Math.max()                求最大值
Math.min()                求最小值
Math.abs()                求绝对值
Math.sqrt()               求开平方
Math.floor()              向下取整
Math.ceil()               向上取整
Math.sin()                三角函数
Math.cos()
Math.tan()
toFixed(n)                留下n位小数
parseInt()                转换成整型：从左到右依次检索遇到的每一个字符；
                                     如果有任意一个非数字字符，会删掉这个字符及后面的全部内容； 如果第一个字符就是非数字，那么会返回Nan；
parseFloat()              转换成浮点：从左到右依次检索遇到的每一个字符；
                                     如果有破坏数字规则的字符，会删掉这个字符及后面的全部内容；
                                     如果第一个字符就是非数字，那么会返回Nan；
Number()                  转换成数字：进行整体的数据类型的变换，只要存在任何不符合数字规则的部                                                                             分，那么久转为Nan；
toString(进制)            十进制转换成其他进制            




#3.数组

##声明

1.var arr=[]                                 括号中所填内容，即为数组内容
2.var arr = new  Array()                     括号中只有一个参数的话，表示长度；否则为数组内容
                    
##.操作

###1.增
arr[index]=新增项
arr.push()	                                 返回值是新数组的length
arr.unshift()		                         将一个或多个元素添加到数组的头部，返回新数组的length


###2.删
arr.pop()                                     返回值是删除掉的数据
arr.shift()                                   删除第一项，返回删除的数据
arr.splice（index,n）                         从下标index开始向后删除n个内容，返回由删除项组成的数组
arr.splice(3,1,"a"，”b“)                      从第三位开始，删除一个数据，并插入一个”a“，”b“，返回由删除项组成的数组

清空数组
arr = []
arr.length = 0

-
###3.改

值的覆盖
arr1.concat(arr2,arr3)                     	  数组的拼接
		
###4.查

for/for in遍历
indexOf（）                                    从前向后，返回第一个匹配项的下标
LastindexOf（）                                从后向前，返回第一个匹配项的下标
5.数组转换成字符串

arr.join("%")	                               转换成字符串，并以%分隔	ps：可以不填符号，拼接成数字字符串
arr.toString()                                 转换成字符串，并以，分隔


#4.字符串
charCodeAt(index)                     查找字符串中下标为index的字符在ASCII中的位置

indexOf(str)                          从左向右返回待查字符串所在下标，没有返回-1   

lastIndexOf(str)                      从右向左返回待查字符串所在下标，没有返回-1


padEnd(10,"0")                        很新，如果当前字符串不满10位，则在其后用0填充至满10位

padStart(10,"0")                      如果当前字符串不满10位，则在其前用0填充至满10位

replace(要替换的内容, 替换后的内容)     在不使用正则表达式时，无法进行全局替换,只能替换查找到第一个目标

String.fromCharCode(97,98,99)         返回由指定的UTF-16代码单元序列创建的字符串

split("/")                            把当前字符串中以/隔开的内容填充到数组里

substring(Start[, End])               返回[start,end)之间的字符;参数可负和NAN，被当作0;会比较参数大小,调换位置;任意                                                        参数大于原字符串长度,则被当作字符串的新长度

slice(beginSlice[, endSlice])         返回[begin,end)之间的字符，参数可负，代表从右向左

例:slice(3,-1)                        返回字符串中第四个字符到倒数第一个字符

toLocaleLowerCase()                   字符串全被转为小写

toLocalUpperCase()                    字符串全部大写





#5.日期对象

var date = new Date("2019/6/20")

getYear()                             获取从1900至目标日期经过的年数
例:date.getYear()                      返回119;

getFullYeatr()                        获取并返回日期中的年份  
getMonth()                            获取并返回月份，返回的数比实际月份小一
getDate()                             获取并返回日     
getDay()                              返回日期所属星期几
getHours()
getMinutes()
getSeconds()
getMilliseconds()                     返回日期中的毫秒
getTime()                             返回1970年1月1日到目标日期经历的毫秒数

getUTCFullYear())                     返回格林威治时间
getUTCMonth())
getUTCDate())
getUTCHours())
getUTCMinutes())
getUTCSeconds())

Date.parse("2015-08-24")              返回从1970到目标日期经过的毫秒数


setFullYear()
setMonth(6)                            将日期的月份改为6+1
setDate()                   
setHours  (hour)
setMinutes(minute)
setSeconds(second)        

#6.BOM Browser Object Model ==》window对象

eval()                           js解析器的调用装置，可将字符串当成代码执行
close()                          关闭当前页面
             
this                             指针，在执行环境中存在；this不建议在全局执行环境中使用，建议在对象中使用；this指向调用者；当事件发生的                                  时候，事件处理函数中的this会指向当前发生事件的元素；定时器中的this指向window；

setInterval(函数名,执行间隔)      定时器，在单个程序之中每个定时器返回的结果都是唯一的;  

var biaozhi = setInterval(函数名,执行间隔);
clearInterVal(biaozhi)           定时器关闭

setTimeout(函数名,执行间隔)       延时器，只会执行一次

伪全局变量：在函数内不声明变量，而是直接赋值；在全局可访问，可删除，真正的全局变量不可被删除

##history

go(+-)                           向前(+)或向后(-)跳转页面
         
back                             向后跳转页面
         
forward                          向前跳转页面

##location(地址栏)

http:// www.baidu.com?key=value#hahahaha
协议       域名        查询语句   哈希值

**属性**
    location.hash = ""                         设置哈希值

    location.href = "09进度条.html"             不带协议是部分更改跳转链接

    location.href = "http://09进度条.html"      带协议是整体更改跳转链接

    location.hostname                           替换|更改域名
    location.protocol                           获取协议
    location.port                               获取端口号
    location.pathname                           获取|更改路径名

**方法**

    location.reload(true)                       相当于alt+f5,底层刷新
    location.replace("URL")                     用给定URL替换当前的资源,调用该方法后,会话历史不会被保存
    location.assign("URL")                      会话历史被保存,有返回之前的页面的回退按钮


#7.DOM  (document object model)
DOM是js里最有用的对象，但是是js设计最失败的对象；

##选择器

getElementById()                id选择器

getElementsByTagName()          标签选择器

getElementsByName()             name选择器

getElementsByClassName()        类选择器

document.querySelector()        选择单个元素

document.querySelectorAll()     选择多个重复元素,返回元素列表

##增加操作：

var box = createElement("div")             创建一个元素标签

父级元素.appendChild(box)                   向后插入，如果操作的元素已经在页面上，那么会删除掉页面上的这个元素，并重新插入；

父级元素.insertBefore(new,old)              在old这个元素之前添加新的元素,与appendChild有相同特性

父级元素.children                           代表父元素里所有的子集元素
父级元素.children[i]                        父元素子集里的第i个元素


##删除操作：

var box = document.getElementById("hello");

document.body.removeChild(box)              删除id="hello"的元素;
    
box.parentNode.removeChild(box)             删除box;
    
box.remove()                                升级语法，看起来很棒;

##更改操作

 var box = document.getElementById("box");

 box.innerHTML = "&lt;h1&gt;内容</h1>";     带标签的字符串直接放在页面上，会把字符串解析成标签内的内容,原样输出需要转义；返回值带标签
    
 box.innerText = "<h1>内容</h1>"            直接原样打印，自带转义：返回值不带标签，只返回内容

##属性操作

 
 var box = document.getElementById("box");

**标签属性操作:**

 box.setAttribute("新属性","属性值")     给标签添加新的属性和属性值

 box.removeAttribute("属性")            移除标签的属性

 box.getAttribute("属性")               返回标签里属性的属性值

**样式属性操作:**

box.style.cssText =""                   覆盖之前的样式属性

box.offsetWidth|offsetHeight            对性能消耗很严重，因为会引起页面回流


getComputedStyle();                     获取元素完整的css列表

window.getComputedStyle(ID名,null).getPropertyValue("display")      获取元素的display的属性值
window.getComputedStyle(ID名)["display"]

例: let elem = document.getElementById("elem-container");
    let theCSSprop = window.getComputedStyle(elem,null).getPropertyValue("background");
    获取id为elem-container的元素的css列表里的background属性值


 简写：

 box.id = ""

 box.className = ""

 box.title = ""

 box.style.width = ""

这样的形式赋值可以，取值的时候尽量不用，因为只能取到行内样式

##节点 dom对象的细化



**nodeType**
 1 : 元素节点; 
 2 : 属性节点; ? => 是元素节点的子集;
 3 : 文本节点; 
 8 : 注释节点; 
 9 : document 节点; 
 11: 文档碎片; 

**节点三剑客:**
var box = document.getElementById("box");
box.nodeType;       辨别节点类型的;
box.nodeName;       返回元素节点名字;
box.nodeValue;      返回节点内的值;

box.childNodes;     返回元素内所有的孩子节点,是一个伪数组;

box.attributes      返回的是伪数组,里面存的是对象.

**节点添加操作:**
var box = document.getElementById("box");

1.添加元素节点
    var div = document.createElement("div");
    box.appendChild(div);

2.添加属性节点
    方法一:
    var myAttr = document.createAttribute("data-hello");
    myAttr.nodeValue = "helloWorld";
    box.setAttributeNode(myAttr);
    方法二:
    box.setAttribute("data-hello","helloworld");

3.添加文本节点
    方法一：
    ar textNode = document.createTextNode("hello world");
    ox.appendChild(textNode);
    方法二：
    ox.innerHTML = "hello world"
    ox.innerText = "hello world"

4.添加注释节点
    box.appendChild(document.createComment("这是一个注释"));



**文档碎片:**
 var fragment = document.createDocumentFragment();
//将多个元素装入fragment中之后再整体写入页面会比较快,而且fragment不会显示在结构中

**offsetTop 测量方法**

box.offsetTop
    1. 所有直至body的祖先级元素, 在这些元素中如果没有position属性, 前offset会测量元素距离文档顶部的值
    2. 如果父级元素有position , 属性那么则会返回当前具有position属到当前元素的距离;

box.offsetParent;
    是一个只读属性，返回一个指向最近的（closest，指包含层级上的最近）包含该元素的定位元素


#8事件对象

 ##概念
    事件:由用户触发的和浏览器进行交互的操作

    对象:结构化存储数据

    事件对象:用于存储事件发生时的所有信息的对象

    Event对象:
    可以处理任何和鼠标键盘相关的信息

 ##获取

    1.**获取Event对象的方式**
        1.浏览器调用时,直接给事件处理函数传递一个参数,该参数中包含事件发生的信息;chrome
        2.浏览器执行事件时,会给全局中的event对象复制当前事件的参数;Firefox
    
    2.**兼容两种方式来获取对象**
        Tip:处理取值类的兼容性问题时,一般采用||运算
        xxx.onclick = function(ev){
        
        var e = ev || event

        } 

 ##鼠标相关

    1.**鼠标按键**
         button值     0 1 2          代表左中右
         buttons值    1 4 2          代表左中右
         例: e.buttons === 3         代表左右键一起按下
    
    2.**鼠标当前位置**
    
        clientX,clientY             鼠标在可视窗口中的坐标

        offsetX,offsetY             鼠标在事件源区域中的坐标

        screenX,screenY             鼠标在显示屏中的坐标

        pageX, pageY                鼠标在文档中的坐标,若水平方向有滚动条：pageX = clientX + scrollLeft

    3.**事件发生的起始点:事件源**
    
        target||scrElement 
        e.target,e.scrElement       事件发生在哪个元素上事件源就是什么;

    4.**杂项**
    
        timeStamp                    时间戳:页面加载完成到发生事件为止,标志着当前事件的独一无二

        Element.clientWidth          属性表示元素的内部宽度，以像素计。该属性包括内填充，但不包括垂直滚动条、边框和外边距。


 ##事件触发分三步：

    1.捕获阶段
    2.目标阶段
    3.冒泡阶段

 ##两套关注流程：

    1.IE            冒泡：目标阶段=》冒泡阶段
    2.NetSpace      捕获：捕获阶段=》目标阶段
    tip：节点.on+事件名 = 函数; 此处只能存在一个事件处理函数

 ##高级事件的绑定模式=》监听

    1.**基本使用**

        dom.addEventListenner("事件名",事件处理函数,false(冒泡)|true(捕获)); 

        >ps:此处的事件名没有on
    2.**监听可以同时存在多个事件处理函数 建议20个以下**

    3.**监听移除**

        dom.addEvenmetListener("事件名",事件处理函数的地址)

    4.**阻止事件冒泡**

        e.stopPropagation();
        e.cancelBubble = true;
        **阻止事件冒泡的兼容性写法**
           typeof e.stopPropagation === "function" ? e.stopPropagation() : e.cancelBubble = true;

 ##拖拽


    1.鼠标按下;     拖拽开始
    2.鼠标移动;     拖拽进行中
    3.鼠标抬起;     拖拽结束
 


 ##改变this指向的方法

    1.**bind()**

        函数名.bind({name:"吴彦祖"},1,2,3);

        >返回一个新函数;
        >一旦函数被bind了，意味着所有函数的this指向规则对其都失效。this指向永远被**固定**为当初建立时设定this指向;
        >bind还可以固定一个形参的值;把正常的参数顺序后延;
        >IE8+

    2.**call();apply();**

        函数名.call({name:"吴彦祖"},1,2,3);
        函数名.apply({name:"吴彦祖"},1,2,3,);

        >二者在函数调用时**改变**this指向;
        >call() 和形参一一对应的赋值
        >apply()时对arguments逐个赋值;

##柯里化

    **函数嵌套,内部函数调用参数函数,并在调用时,绑定this的指向**

##浏览器默认事件

    **默认事件**
    
         1.图片拖拽
         2.右键菜单             
         3.form表单的提交
         4.input 输入框
         5.checkbox
         6.a标签

    **阻止默认菜单事件**
```javaScript
    
    document.oncontextmenu = function(evt){
     var e = evt || event;
     //短路运算,阻止默认事件的兼容性写法
     typeof e.preventDefault === "function" ?
      e.preventDefault() : e.returnValue = false
    }
```
    


#事件的委托
    **概念**
        把原本绑定(监听)给多个元素的事件,监听给这些元素的父级.
        在触发事件阶段验证事件源的身份,来辨别事件触发是否合法.
    **存在的意义**
        常规的事件绑定会导致大量冗余事件,使用事件的委托可以解决这样的问题;


 ##事件委托的封装
    **遇到的问题**
        事件绑定时不太好传递参数;
    **解决方法**
        函数内部返回一个函数

 ```javaScript
           //delegation => 整合两个函数 ; 1. 匿名函数; 2. 事件处理函数(handlerClick);
           //事件执行的时候 匿名函数会执行; 
           //  匿名函数的作用 判定是不是应该调用 handlerCLick;
             var ul = document.querySelector("ul");
             ul.addEventListener("click",delegation(handlerClick,"LI"))
             function delegation(handlerClick , selector ){
                   return function(evt){
                         // console.log(this); // 永久指向ul
                         var e = evt || window.event;
                         var target = e.target || e.srcElement;
                         // console.log("匿名函数",target);
                         if(target.nodeName === selector){
                               handlerClick.call(target,e);
                         }
                   }
             }
              function handlerClick(e){
                   console.log("事件执行",this,e);
             }
 ```

#ESS5 
    是目前公认的稳定兼容版本

 ##严格模式
    "user strict"
    可以提高代码的执行效率
    1.全局严格
    2.局部严格


    1.变量的严格:严格模式下,变量必须先声明再赋值;
    2.参数的严格:形参被赋值,不会影响到arguments里面的参数;
```JavaScript
      ;(function(){
            "use strict"
            function foo(a,b){
                  // 形参被赋值不会影响到arguments里面的参数;
                  a = 10;
                  b = 20;
                  console.log(a,b,arguments[0],arguments[1])
            }
            foo(1,2)  //打印结果 10 20 1 2
      })();
```
    3.不允许函数中的this指向window.原本指向window的现为undefined;
    4.不允许使用argument.callee;
    5.不允许函数中的形参名重复;


 ##ESS5数组方法

    **  1.forEach(迭代) **
```javaScript
  var arr = [1,2,3,4,5,6,6,7,9];
            arr.forEach( foo )
            function foo( item , index , arr){
                  console.log(item , index , arr);    
            } 
```
        >是用来遍历数组的;
        >forEach中传入的实参是个函数;
        >并在方法内调用*参数函数*数组项数次;
        >这个作为参数的函数里可以传入三个形参:item,index,arr;
        >返回值为undefined;
       
    **2.map(映射)**

```javaScript
          var arr = [15000,20000,21000,26000,3000,2000,8000];

            var newArray = arr.map( function ( item , index ){
                  return item * 1.3;
            })
            console.log(newArray)
            console.log( arr.map( item => item * 1.3));
```
        >返回一个新数组,新数组中装的是参数函数的返回值

    **3.filter(过滤器)**

 ```JavaScript
  var arr = [15000,20000,21000,26000,3000,2000,8000];
             var newArray = arr.filter( function(item , index){
                   return item >= 10000;
             } )
             console.log(newArray);
 ```
        >返回新数组,会根据参数函数的返回值判定是否该将具体的项加入新数组;

    **4.some**
      
```JavaScript
        var arr = [15000,20000,21000,26000,3000,2000,8000];
            var boolean = arr.some( function (item , index , arr){
                console.log(item);
                return item === 3000
            })
            console.log(boolean);
```
        >判定数组中是否存在某个符合条件的值;一旦函数返回true,那么some就会终止循环;

    **5.every**

```javaScript
  var arr = [15000,20000,21000,26000,3000,2000,8000];
            var boolean = arr.every(function( item , index , arr){
                  // console.log(1);
                  return item % 2 === 0
            })
            console.log(boolean);
```
        >判断数组中的所有数据是否满足某一条件;一旦函数返回false,那么every就会停止循环;

    **6.reduce**

```javaScript
    var arr = [15000,20000,21000,26000,3000,2000,8000];

            var res = arr.reduce(function(pre , now , index , arr){
                  console.log(pre,now ,index);
                  return pre + now;
            })
            console.log(res);  //实现累加

```     
        >归并
        >pre表示上一次的运算结果
        >第一次参数不全,直接略过第一次

    **7.flat**

 ```javaScript
    var arr = [
                   [1,2,3,4,5],
                   [2,3,4,5,7]
                     ]
                     console.log(arr.flat());
```
        >实现数组的扁平化


 ##ESS5新增Object方法

    **Object.defineProperty()**
   
    1. **扩展了对象的属性**

```JavaScript
     var obj = {}
    Object.defineProperty( obj, "a" ,{
        //不可删除
        configurable:false;
        //不可枚举
        enumerable:false;
        //a属性的属性值;
        value:"hello world";
        //可写性,默认为false
        writable:true;
    } )
```
    2.**set,get拦截器**

```javaScript
    var obj = {
        $data:{}//如果不用$data储存,会无限调用拦截器函数;
    }
    Object.defineProperty( obj, "a" ,{
          get : function(){
              //this=>object
                return this.$data.a; 
          },
          set : function(val){
               return this.$data.a = val;
          }
    } )
    obj.a
```
       设置拦截器后,获取或改变a的属性值时,会调用get,set拦截器函数.


#正则表达式

##创建正则
    方法一:
 ```JavaScript
     var reg  = new RegExp("规则","g");// i g y
     console.log(reg)  // 输出结果: /规则/g
 ```
    方法二:
    var reg = /\d+/g

    1.规则简写=> \d; 数字                  \D;非数字
                \w;数字字母下划线           \W;非数字字母下划线
                .;匹配所有的字符\n\r除外    [\s\S];匹配所有字符

    2.量词    => + ;{1,} 最少一个,最多不限;
                 * ;{0,} 最少0个,最多不限;
                 ? ;{0,1}没有或者有一个

    3.修饰符  =>    表示正则整体的匹配规则;

        i是ignoreCase,忽略大小写的意思;
        g是全局匹配的意思;
        m是执行多行匹配;
    4.^ 辨别开头
      $ 辨别结尾
       
##正则的相关方法

**test**
```javaScript
    var reg = /abc/;
    var str = "abcde";
    reg.test(str);
```
        >正则的方法
        >判断这个字符串是否含有符合要求的片段,返回true或false

**exec**

```javaScript
     var namelist = "吴彦祖a彦祖c彦祖刘彦祖张彦祖杨彦祖祖彦祖徐彦祖马彦祖";
    var reg = /./g;  //全局匹配任意字符
    console.log(reg.exec(namelist)); //打印第一个字符
```
        >正则的方法;
        >在字符串中找到一个符合规则的内容;
        >如果有g,那么下一次匹配的时候会在上一次匹配终止处继续;

**search**
```javaScript
    var pattern = /good/ig;
    var str = 'good good study!，day day up!';
    console.log(str.search(pattern));
```

    >字符串的方法;
    >返回第一个匹配项的下标

**math**
```JavaScript
    var str "123dadfas123ds45fd6afds3af486das1df2as346";
    var reg = /\d+/g;
    console.log(str.match(reg))  ;
```
         >字符串的方法;
         >在字符串之中匹配所有符合规则的字符，并以数组形式进行返回;
         >如果匹配到的结果只有一个; 那么他会返回这个匹配内容的下标,匹配字符串，组别.....


##元字符
```javascript
var namelist = "吴彦祖a彦祖c彦祖刘彦祖张彦祖杨彦祖祖彦祖徐彦祖马彦祖";
    // var reg = /杨彦祖|刘彦祖|张彦祖/g;
    var reg = /[^杨]彦祖/g;
    console.log(namelist.match(reg));  //打印结果没有杨彦祖
```
        >元字符是正则之中 | 运算符的简写,元字符之中所有的字符和前面或者后面的规则进行匹配,得到一组匹配结果;
        >\d = 元字符 >[0-9];
        >第一个符号 - :用来告知数字和字母的范围;
        >第二个符号 ^ :用来排除元字符之中的字符;

##贪婪和惰性

**惰性**
>只匹配到一个就够了

**贪婪**
1.与量词有关
2.与g的区别
 >贪婪是尽可能多的匹配符合队则的字符 => 一次尽可能匹配更多
 >g修饰符驱动方法多次匹配           => 在整条字符串上多次进行匹配

#面向对象

1.面向对象的目标:问题的解决方案;

2.面向对象的重点:分工;

3.面向对象编程:
    OOA(Object-oriented Analysis)   :面向对象分析;
    OOD(Object-oriented Design)     :面向对象设计;
    OOP(Object-oriented programming):面向对象编程;
##构造函数

1.作用:批量创建对象;
2.内部拆解: 1.在构造函数开头创建一个对象(实例);
             2.在构造函数结尾返回实例;
3.构造函数和普通函数的区别:
 >调用方式不同;
 >构造函数 new 函数名() 来创建对象;

##构造函数,原型,实例

1.构造函数和原型的关系:伴生;
2.构造函数和实例的关系:创建;
3.实例    和原型的关系:实例的原型指针指向原型;

>实例可以通过原型链访问原型对象中的属性和方法;
> Object.prototype.isPrototypeOf(foo.__proto__) 
    判定 Object.prototype 是否在  foo.__proto__ 的原型链之中;


#ES6

##简介

    1.ES6是js进步最大的一版更新;
    2.疑难杂症解决方案,异步解决方案;
     >promise
     >async await
    3.语法糖:更加清爽,更加有bigger;
    4.兼容性有一定的问题;

##变量声明

**let 声明变量**

1.有块级作用域的概念,也就是大括号作用域,不再仅限于函数的大括号作用域;
 >可以减少匿名函数的使用频率;
 >for循环里的大括号访问小括号里的值,大括号作用域是小括号作用域的子集;for循环每次执行都会创建一个AO;
2.不允许声明提升了;自动形成闭包;
 >暂时性死区:在声明变量的时候,变量之前的所有空间,不允许使用这个变量;
3.在同一作用域之中,不允许重复声明变量

**const 声明常量**
 >定义之后不可赋值;

 >存地址

##解构赋值

**数组赋值**

let [a,b,c,d] = [1,2,3,4,5,6];

>按位赋值

**剩余运算赋值**

let [a,b,c,...d] = [1,2,3,4,5,6,7,8,9]

>按位赋值,剩余的给d

**对象赋值**

```javascript
    let obj = { a : 10}
    let { a } = obj;
    // var a = obj.a;
    console.log(a); //10
```


1.对实例之中的方法进行一个方便的取值

```javascript
 let { slice , concat } = Array.prototype;
            console.log(slice,concat);
```
2.改名机制

```javascript
     // { 原有属性 : 新变量名 }
    let { slice : mySlice , concat } = Array.prototype;
    // let mySlice = Array.prototype.slice;
    console.log(mySlice)
```
3.带有默认参数的赋值

```JavaScript
let { a = 10, b = 20 } = { a : 30 , b : 40};
            console.log(a,b);
```
    默认参数写法
```javascript
  function Banner(options){
                  options ? "" : options = {};
                  let { a = 10 , b = 20} = options; 
                  console.log(a,b);
            }

             Banner({
                  a: 30 
            });    //a的值被覆盖
```
 另一种写法
 ```javascript
  function Banner( { a = 10 , b = 20 } = {}){
               console.log(a,b);
            }
            Banner({
                  a : 40
            });
 
 ```

4.对象的扩展:扩展运算符

```javascript
     var obj2 = {
                  d : 40 ,
                  e : 50 ,
                  f : 60
            }
            var obj1 = {
                  ...obj2,
                  a : 10,
                  b : 20,
                  c : 30
            }

```

 对象赋值总结:
    1.基本结构:=>对象结构要求左右两侧必须均为大括号,否则报错;

    2.基本使用:变量声明,属性赋值;
    let {a,b} = {a : 1,b : 2};
    //声明了变量a和b,并且给变量赋值为对象.a 和对象.b;

    3.变量别名  给 c 变量赋值 对象.a 的属性值;
     let { a : c , b } = { a : 1, b:2} ;
     console.log(c,b)//1,2

##箭头函数
>函数的部分替代品
>箭头函数和匿名函数极其相似
>箭头函数,声明时都是匿名的
>箭头函数其实只能作为函数的封装和复用的代码块包裹使用了;
>基本形式:(参数) =>{代码}

1.支持return 关键字;
2.箭头函数不支持arguments关键字;
3.this指向规则发生了改变;
>在创建箭头函数时,就已经确定了函数的this的指向,this不再随着调用者的改变而改变了;
>bind,call,apply失效
>箭头函数作为事件处理函数时,this不指向事件触发的元素了;
>箭头函数不能作为原型中的方法,因为this指向也是固定的,无法访问实例之中的属性;
4.箭头函数不能作为构造函数;

#字符串模板

1.``反引号拼接字符串很方便
2.字符串模板之中的变量拼接: ${字符串变量}

3.模板引擎
	就是在写HTML的时候放入JS逻辑,用js逻辑将字符串输出到页面
	在script标签type为text/html的时候,内部的所有代码不会解析,只会当成字符串
	使用
		1.拆分逻辑部分
			<% 逻辑代码 %>
		2.拆出html部分
			未被包裹的是html拼接的字符串
		3.逻辑执行
			eval()将字符串当成代码来执行
		4.字符串返回
#Symbol(符号)
	创建符号类型
		let sym = Symbol("接受参数"); 
	每次创建都唯一

#set,map
	set
		创建 var set = new Set([2,3,4])
		结构 值=>值
		特点 不存在重复项
	map
		键值对结构
#class
	构造函数+原型的语法糖

	constructor() 相当于构造函数

	get用法>复杂的需求和数据导致某些数据要经过实时运算才可以准确返回
    
    静态资源和实例没有关系





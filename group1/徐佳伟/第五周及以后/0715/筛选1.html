<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>筛选</title>
    <style>
        .protected{
            width: 200px;
            height: 200px;
            background: #f0f;
            position: relative;
        }
        div{
            width: 100px;
            height: 30px;
            background: #000;
            position: relative;
        }
    </style>
</head>
<body>
        <!-- <div class="protected"></div><div></div> -->
    <ul>
        <li class="li"><a href=""></a></li>
        <li class="li"><a href=""></a></li>
        <li class="li"><a href=""></a></li>
        <li class="li"><a href=""></a></li>
        <li id="li"><a href=""><span><a href=""></a></span></a></li>
        <li id="li1"></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
    </ul>
   
        <script src="../../libs/jquery.js"></script>
    <script>
        //本专题为筛选方法
        //筛选的是选择的元素而不是判断的元素

        //匹配获取第二个p元素,下面两种方法都可以
        // $("p").eq(1);
        // $("p").eq(-2)
        //first第一个元素 last最后一个元素
        
        //hasClass  选择包含某个类的元素
        // $("div").click(function(){
        //     if ( $(this).hasClass("protected") )
        //         $(this)
        //         .animate({ left: -10 })
        //         .animate({ left: 10 })
        //         .animate({ left: -10 })
        //         .animate({ left: 10 })
        //         .animate({ left: 0 });
        // });

        //filter 跟选择器差不多了 什么都能加
        //元素 函数 伪类 都可以

        //is()返回的是一个布尔值
        //is(str|obj|fn|ele)四大类型

        //$.map(fn)
        //将一组元素转换成其他数组，不论是否为元素数组
        // console.log($("li").map(function(){

        //     return $(this);
        // }))
        // 获取了一个元素数组

        // has(ele|str) 包含
        // $("li").has("a").css("background","red");
            
        //not不选择符合规定条件的元素
        // console.log($("li").not($("#li")[0])   )
        
        // slice用法和原生的方法差不多
        
        //children还真把所有li下的子元素找到了啊还装在一个数组里
        //还好只找到了子集那一层
        //children括号里依旧可以添加过滤器
        // console.log($("li").children());

        // closest和parents的主要区别是：1，前者从当前元素开始匹配寻找，后者从父元素开始匹配寻找；
        // 2，前者逐级向上查找，直到发现匹配的元素后就停止了，后者一直向上查找直到根元素，然后把这些元素放进一个临时集合中，再用给定的选择器表达式去过滤；
        // 3，前者返回0或1个元素，后者可能包含0个，1个，或者多个元素。
   
        //  find 从所有的段落开始，进一步搜索下面所有的span元素。与$("p span")相同
        // console.log($("li").find("a"))返回一个a的数组
        
        // next 找到每个段落的后面紧邻的同辈元素
        //注意是每个段落
        //每个li都查找了它下一个的li放在一个数组中
        //----------------------------------------------next(参数)略迷
        // console.log($("li").next("#li1"));
        //nextAll()
        //nextUntil()
        
        //offsetParent()返回第一个匹配元素用于定位的父节点。
        // 这返回父元素中第一个其position设为relative或者absolute的元素。此方法仅对可见元素有效。

        //parent()查找每个段落的父元素 parents
   
   
   
   
   
   </script>
</body>
</html>
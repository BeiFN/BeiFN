<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        *{margin: 0; padding: 0}
        #wrap{
            width: 200px;
            height: 200px;
            background: #aaaaaa;
            border-radius: 10px;
            position: absolute;
            text-align: center;
        }
        #bar{
            width: 200px;
            height: 50px;
            background: #479;
            border-radius: 10px 10px 0 0; 
            text-align: center;
            line-height: 50px;
            font-size: 25px;
            color: #fff;
        }
    </style>
</head>
<body>
    <div id="wrap">
        <div id="bar">拖拽条</div>    
        <button id="replay">回放</button>

    </div>
    <script>
        //拖拽实现 1.首先进行布局 2.拖拽的开始从鼠标点击bar开始，为bar设置监听事件
        //3.首先获得点击点到事件源的left值和top值，然后获得到当前可视窗口的值，
        //4.监听鼠标移动事件，给事件源的left和top赋值

        //当鼠标再bar上点击的时候，给外边的wrap绑定移动的事件，当鼠标从bar上抬起的时候，解除wrap的移动事件

        //获得点击的位置到当前元素的左边和顶部的距离
        var wrap = document.getElementById("wrap");
        var bar  = document.getElementById("bar");
        var replay = document.getElementById("replay");
        // var startX = 0, startY = 0;
        var track = [];
        var _tempMove = null;

        bar.addEventListener("mousedown", handlerClick);
        bar.addEventListener("mouseup", moveEnd);
        replay.addEventListener("click", back);
        function handlerClick(evt){
            var e = evt || window.event;
            startX = e.offsetX;
            startY = e.offsetY;
            wrap.addEventListener("mousemove", _tempMove = move.bind(false, {startX:startX, startY:startY}));
        }
        function move(_client, evt){
            var e = evt||window.event;
            var leftX = e.clientX;
            var topY = e.clientY;
            // console.log(leftX, topY);
            wrap.style.left = leftX -  _client.startX + "px";
            wrap.style.top = topY - _client.startY + "px";
            track.push({
                x:(leftX - _client.startX),
                y:(topY - _client.startY)
            });
        }
        //绑定鼠标抬起函数，当鼠标从bar抬起时解除和bar的绑定，则不再执行bar监听函数中的事件
        function moveEnd(){
            // this.removeEventListener("mousedown",handlerClick);
            wrap.removeEventListener("mousemove", _tempMove); //当鼠标从bar上抬起的时候解除移动
        }
        //实现拖拽条按原路返回应该将原来的鼠标移动触发的位置的改变存放在一个数组中，然后实现数组的倒序遍历输出
        function back(){
            var count = track.length-1;
            var timer = setInterval(() => {
                wrap.style.left = track[count].x + "px";
                wrap.style.top = track[count].y + "px";
               count--;
               if(count < 0){
                   clearInterval(timer);
                   timer = null;
                   return 0;
               }
            }, 50);
        }
        
    </script>
</body>
</html>
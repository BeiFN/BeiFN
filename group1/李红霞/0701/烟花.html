<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
            #container{
                  width: 600px;
                  height: 400px;
                  background:#040;
                  border: 2px solid #aaa;
                  position: absolute;
                  left: 0;
                  top: 0;
                  bottom: 0;
                  right: 0;
                  margin: auto;
            }      
            
            .firework{
                  width: 7px;
                  height: 7px;
                  border-radius: 50%;
                  background: #fff;
                  position: absolute;
            }
      </style>

</head>
<body>
    <div id="container"></div>
    <script>
        //用面向对象的方法实现烟花效果
        //步骤：1.创建构造函数，获取事件元素设为构造函数的属性，2.绑定监听事件，设为原型的方法
        function FireWork(selector){
            //获取要操作的元素设为构造函数的属性
            this.container = document.getElementById(selector);
            //在构造函数中调用init方法对构造函数创建的对象的初始化方法进行调用
            this.init();
        }
        //将处理对象的方法写在原型函数中
        FireWork.prototype.init = function(){
            this.container.addEventListener("click", handlerClick.bind(this))
        }
        
        //当用户点击container时会执行事件，1.创建一个元素 2.元素运动到鼠标点击处消失

        //处理用户点击的事件处理业务函数
        function handlerClick(evt){
            var e = evt||window.event;
            var offsetX = e.offsetX;
            var offsetY = e.offsetY;
            var ele = changeElement(offsetX);
            this.container.append(ele);
            //当元素被添加进页面之后就开始进行运动
            move(ele, {
                top:offsetY,
            }, this.fireworkBoom.bind(this, offsetX, offsetY));  //当烟花运动到鼠标位置时调用fireworkBoom函数并移出该元素
            //当元素运动到目标位置时，该元素即从页面中删除，再从页面中创建
        }
        //复用性较高的函数放在对象外面，复用性较低的函数放在对象的原型对象中
        //处理烟花运动到鼠标点击处爆炸的函数
        FireWork.prototype.fireworkBoom = function(offsetX, offsetY){
            // 元素停止后创建15-20个元素 元素运动围成一个圆形，在半径为100-150的园处消失   
            var randomCount = 15 + parseInt (Math.random() * 10);  
            var radius = 100 + parseInt(Math.random() * 50);
            for(var i = 0; i < randomCount; i++){
                var ele = changeBoomElement(offsetX, offsetY);
                this.container.appendChild(ele);
                var targetX = parseInt(radius*Math.cos(Math.PI/180*360/randomCount*(i+1)))+ offsetX;
                var targetY = parseInt(radius*Math.sin(Math.PI/180*360/randomCount*(i+1))) + offsetY;
                move(ele, {
                    "top":targetY,
                    "left":targetX
                },function(){
                    ele.remove();
                })
            }          
        }
        //改变爆炸的元素属性的函数
        function changeBoomElement(offsetX, offsetY){
            var ele = createElement();
            ele.style.top = offsetY + "px";
            ele.style.left = offsetX + "px";
            ele.style.backgroundColor = "#" + parseInt(parseInt("ffffff", 16)*Math.random()).toString(16).padStart(6, "0");
            return ele;
            console.log(ele)
        }
        //处理元素初始运动的函数
        function move( dom , options , callback){
                  clearInterval( dom.timer );
                  dom.timer = setInterval( function(){
                        // console.log(1);
                        // 根据 attr 判定获取 iNow;
                        // 根据iNow 和 target 获取 speed;
                        // 根据target和 iNow 判定终止条件;
                        // 根据attr 判定 dom操作;
                        // * attr  target;
                        for(var attr in options){
                              // console.log(attr,options[attr]);
                              if( attr === "opacity"){
                                    var iNow = parseInt(getComputedStyle(dom)[attr] * 100 )
                              }else{
                                    var iNow = parseInt(getComputedStyle(dom)[attr])
                              }
                              // console.log(attr , iNow);
                              // target => options[attr];
                              var speed = (options[attr] - iNow) / 10;
                              speed = speed > 0 ? Math.ceil(speed):Math.floor(speed);

                              if(options[attr] === iNow){
                                    // 所有属性运动结束之后再去关闭定时器;
                                    delete options[attr];
                                    if(Object.keys(options).length === 0){
                                          clearInterval(dom.timer);
                                          dom.remove();
                                          typeof callback === "function" ? callback() : "";
                                    }
                              }else{
                                    if(attr === "opacity"){
                                          dom.style[attr] = (iNow + speed) / 100;
                                    }else{
                                          dom.style[attr] = iNow + speed + "px";
                                    }
                              }
                        }
                  } ,50)
            }

        //改变元素属性样式的函数
        function changeElement(offsetX){
            var ele = createElement();
            ele.style.left = offsetX + "px";
            ele.style.backgroundColor = "#" + parseInt(parseInt("ffffff", 16)*Math.random()).toString(16).padStart(6, "0");
            ele.style.bottom = 0;
            return ele;
        }
        //创建随即颜色元素的函数
        function createElement(){
            var ele = document.createElement("div");
            ele.className = "firework";
            ele.style.backgroundColor = "#fff"
            return ele;
        }

        var firework = new FireWork("container")
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>排序</title>
</head>
<body>
    <!-- 冒泡排序：******************** -->
        <!-- 原理：比较两个相邻的元素，将值大的元素交换至右端。 -->

        <!-- 思路：依次比较相邻的两个数，将小数放在前面，大数放在后面。
        即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。
        然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，
        直至比较最后两个数，将小数放前，大数放后。重复第一趟步骤，直至全部排序完成。 -->

    <!-- 选择排序***********************-->
        <!-- 原理：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，
        然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。
        以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。 -->

    <!-- 快速排序 ***********************-->
        <!-- 它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，
        其中一部分的所有数据都比另外一部分的所有数据都要小，
        然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，
        以此达到整个数据变成有序序列。 -->

    <script>
        var arr = [1,5,6,89,7,11,12,12,34];
        // 冒泡********************************************************************
        // function  sort1(arr){
        //     for(var i=0 ; i< arr.length - 1 ;i++){
        //         for(var j = 0; j < arr.length - i -1 ;j++ ){
        //             if(arr[i] > arr[i+1]){
        //                 var temp = arr[i];
        //                 arr[i]  = arr[i+1];
        //                 arr[i+1] = temp;
        //             }
        //         }
        //     }
        //     console.log(arr);
        // }
        // sort1(arr);

        // //选择******************************************************************
        // function sort2(){
        //     for(var i=0 ; i< arr.length - 1 ;i++){
        //         for(var j = 0; j > arr.length - i -1 ;j++ ){
        //             if(arr[j] > arr[i+1]){
        //                 var temp = arr[j];
        //                 arr[j]  = arr[i+1];
        //                 arr[i+1] = temp;
        //             }
        //         }
        //     }
        //     console.log(arr);
        // }
        // sort1(arr);

        // //桶排序 不仅可以排序还可以自动去重****************************
        // var bocket = [];
        // for(var i = 0 ; i <arr.length ; i++){
        //     bocket[arr[i]] = true;
        // }
        // arr.length = 0;
        // for(var index in bocket){
        //     arr.push(Number(index));
        // }
        // console.log(arr)

        // 最简单的排序*****************************************************
        // arr.sort(function(a,b){
        //       return a - b
        // });          
        // console.log(arr);  
        // arr.reverse();
        // console.log(arr);

        // 快速排序********************************************************
        // function fastSort(arr){
        //     if(arr.length <= 1) return arr;
        //     var midIndex = parseInt(arr.length / 2);
        //     var mid = arr[midIndex];
        //     var leftArr = [];
        //     var rightArr = [];
        //     for(var i = 0 ; i<arr.length; i++){
        //         if(i === midIndex) continue;
        //         if(mid < arr[i]){
        //             rightArr.push(arr[i]);
        //         }else{
        //             leftArr.push(arr[i]);
        //         }
        //     }
        //     return fastSort(leftArr).concat([mid],fastSort(rightArr));
        // }
        // console.log(fastSort(arr));
        
    </script>
</body>
</html>
整理的一些比较新的API：

关于String.prototype :

1.endswith( ) 用来判断当前字符串是否是以另外一个给定的子字符串“结尾”的

​						结果返回 `true` 或 `false`。

   语法：  str.endsWith(searchString[, length])

​					searchString：要搜索的子字符串	length：`str` 的长度

 	注：这个方法是大小写敏感的。

示例：

```js
var str = "To be, or not to be, that is the question.";

alert( str.endsWith("question.") );  // true
alert( str.endsWith("to be") );      // false
alert( str.endsWith("to be", 19) );  // true    //"To be, or not to be"的长度是19
```

2. startsWith( )  用来判断当前字符串是否以另外一个给定的子字符串开头

   ​				根据判断结果返回 `true` 或 `false`。

     语法：  str.startsWith(searchString[, position])

   ​					searchString：要搜索的子字符串	

   ​				position：`在 `str` 中搜索 `searchString` 的开始位置，

   ​									默认值为 0，也就是真正的字符串开头处。

    注：此方法是区分大小写的。

   ```js
   var str = "To be, or not to be, that is the question.";
   
   alert(str.startsWith("To be"));         // true
   alert(str.startsWith("not to be"));     // false
   alert(str.startsWith("not to be", 10)); // true  //下标10正是n，故为true
   ```

3. includes( ) 用于判断一个字符串是否包含在另一个字符串中

​						结果返回 `true` 或 `false`。

   语法：  str.includes(searchString[, position])

​					searchString：要在此字符串中搜索的字符串。

​					position：从当前字符串的哪个索引位置开始搜寻子字符串，默认值为0。

 	注：这个方法是大小写敏感的，即`includes()` 方法是区分大小写的。

​			例：'Blue Whale'.includes('blue');     // returns **false**

示例：

```
var str = 'To be, or not to be, that is the question.';

console.log(str.includes('To be'));       // true
console.log(str.includes('question'));    // true
console.log(str.includes('nonexistent')); // false
console.log(str.includes('To be', 1));    // false	// 若是从0开始检索，则为true
console.log(str.includes('TO BE'));       // false
```





关于String.prototype :

1. Array.from( ); 从一个类似数组或可迭代对象中创建一个新的，浅拷贝的数组实例.

   ​				返回值：一个新的数组实例

   语法：Array.from(arrayLike[, mapFn[, thisArg]])

   ​				arrayLike：想要转换成数组的伪数组对象或可迭代对象。

   ​				mapFn (可选参数):如果指定了该参数，新数组中的每个元素会执行该回调函数。

   ​				thisArg (可选参数):可选参数，执行回调函数 `mapFn` 时 `this` 对象。

   示例：

   ```js
   console.log(Array.from('foo'));
   // output: Array ["f", "o", "o"]
   
   console.log(Array.from([1, 2, 3], x => x + x));
   //  output: Array [2, 4, 6]
   
   let s = new Set(['foo', window]); 
   Array.from(s); 
   // ["foo", window]
   
   let m = new Map([[1, 2], [2, 4], [4, 8]]);
   Array.from(m); 
   // [[1, 2], [2, 4], [4, 8]]
   
   function f() {
     return Array.from(arguments);
   }
   f(1, 2, 3);
   // [1, 2, 3]
   
   function combine(){ 
       let arr = [].concat.apply([], arguments);  //没有去重复的新数组 
       return Array.from(new Set(arr));
   } 
   var m = [1, 2, 2], n = [2,3,3]; 
   console.log(combine(m,n));  
     // [1, 2, 3]					//似懂非懂，看结果能理解，但自己解释不了。
   ```

   

2. fill( )  用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。**不包括终止索引**。

   ​			返回值：修改后的数组

   语法：arr.fill(value[, start[, end]])        即  [ 起始索引, 终止索引  )  范围内被替换乘value

   ​				   value：用来填充数组元素的值。

   ​					`start` 可选：起始索引，默认值为0。

   ​									如果 `start` 是个负数, 则开始索引会被自动计算成为 `length+start`

   ​					`end` 可选：终止索引，默认值为 `this.length`。

   ​									如果 `end` 是个负数, 则结束索引会被自动计算成为 `length+end`。

   示例：

   ```js
   [1, 2, 3].fill(4);               // [4, 4, 4]
   [1, 2, 3].fill(4, 1);            // [1, 4, 4]
   [1, 2, 3].fill(4, 1, 2);         // [1, 4, 3]
   [1, 2, 3].fill(4, 1, 1);         // [1, 2, 3]
   [1, 2, 3].fill(4, 3, 3);         // [1, 2, 3]
   [1, 2, 3].fill(4, -3, -2);       // [4, 2, 3]
   [1, 2, 3].fill(4, NaN, NaN);     // [1, 2, 3]
   [1, 2, 3].fill(4, 3, 5);         // [1, 2, 3]
   Array(3).fill(4);                // [4, 4, 4]
   [].fill.call({ length: 3 }, 4);  // {0: 4, 1: 4, 2: 4, length: 3}
   
   // Objects by reference.
   var arr = Array(3).fill({}) // [{}, {}, {}];  //数组内有三个{ }
   arr[0].hi = "hi"; // [{ hi: "hi" }, { hi: "hi" }, { hi: "hi" }]
   ```

   


<!DOCTYPE html>
<html lang="en">
<head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="X-UA-Compatible" content="ie=edge">
      <title>对象的深克隆与浅克隆</title>
</head>
<body>	
	<script type="text/javascript">
		var obj={
			a:1,
			"d":"$",
			2:true,
			"@":3.9
		}
		 console.log(obj);
		 // 引用传递  <= 浅克隆;
		 var cloneObj=obj;
		 console.log(cloneObj);
		 
		  // 最简单的深克隆 ; 	// for 克隆 ; 
		  var cloneObj1={};
		  for (var attr in obj) {
		  	cloneObj1[attr]=obj[attr];
		  }
		  console.log(cloneObj1);
		  
		  
          // 复杂形势的克隆
		  // 克隆 内部存在引用类型的对象;
		  var obj = {
                  a : 10,
                  b : [],
                  c : {
                        d : 1,
                        e : {},
                        f : []
                  }
            }
			// for 克隆
			var cloneObj2={};
			for(var attr in obj){
                  cloneObj2[attr] = obj[attr];
            }
            console.log(cloneObj2);
			
			// 一行代码完美深克隆
			var clon=JSON.stringify(obj);
				clon=JSON.parse(clon);
			console.log(clon);
			
			// 表层不用for循环的深克隆;  => 只能有一层;
			var clonObj4=Object.assign({},obj)
			console.log(clonObj4);
			
			
			// 递归
			function cloneOb(obj){
				var newo={};
				for (var attr in obj) {
					if (typeof obj[attr]==="object") {
						newo[attr]=obj[attr] instanceof Array? obj[attr].toString().split(","):cloneOb(obj[attr]);
					}else{
						newo[attr]=obj[attr];
					}
				}
				return newo;
			}
			var cloneObj3=cloneOb(obj);
			console.log(cloneObj3);
			
			
			// 对象合并方法 => ES6:	Object.assign
            var obj1 = { "&" : 1 , "?" : []};
            var obj2 = { b : 2};
			var obj3=Object.assign(obj1,obj2,obj);
			console.log(obj3);
			
			
			// 函数的拷贝
			function foo(){
				console.log("hello world");
			}
			var cloneFoo=eval("("+foo.toString()+")");
			console.log(cloneFoo);
			
	</script>
</body>
</html>
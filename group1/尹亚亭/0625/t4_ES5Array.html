<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>ES5新增的数组方法</title>
	</head>
	<body>
		<script type="text/javascript">
			// forEach |  map |  filter | some | every | reduce 
			
			//forEach( function(item, index, arr){ })
			// forEach 没有返回值 返回值为undefined;
			var arr1 = [1, "@", 2, 3, "$", 4, 5, 8, "&", 6, 7, 9];
			arr1.forEach(foo1);
			// function foo1(item, index, arr) {
			// 	console.log(item, index, arr);
			// }
			function foo1(item, index) {
				console.log(item, index);
			}
			// 封装
			function myForEach(arr,fn){
				for (var i=0;i<arr.length;i++) {
					fn(arr[i],i,arr);
				}
			}
			myForEach(arr1,function(item,index,arr){
				console.log(item,index);
			})
			
			// map 返回一个新数组，新数组之中装的是参数函数的返回值;
			//map( function(item, index, arr){ })
			var arr2=[1235,653,865,96,7,24869,990];
			//使用forEach
			var res=[];
			arr2.forEach(function(item){
				res.push(item*1.2);
			})
			console.log(res);
			// 使用map
			var newArray=arr2.map(function(item,index){
				return item+500;
			})
			console.log(newArray);
			// ES6新用法
			console.log(arr2.map(item=>item/0.75));
			// 封装forEach
			function myMap(arr,fn){
				var res=[];
				for (var i=0;i<arr.length;i++) {
					res.push(fn(arr[i],i,arr));
				}
				return res;
			}
			myMap(arr2,function(item,index){
				console.log(item-99,index);
			})
			
			//filter  返回新数组.会根据参数函数的返回值判定是否该将具体的项加入新数组;
			//filter( function(item, index, arr){ })
			var arr3=[21,34,51,98,62,93,30,755,831,998,1000]
			var newARray=arr3.filter(function(item,index){
				if (item%2 == 0) {
					return item;
				}
			})
			console.log(newARray);
			// 封装
			function myFilter(arr,fn){
				var res=[];
				for (var i=0;i<arr.length;i++) {
					if(fn(arr[i],i,arr)){
						res.push(arr[i]);
					}
				}
				return res;
			}
			var newARray2=myFilter(arr3,function(item,index){
				if ( item%2) {	//选出是奇数的数 item%2!==0
					return item;
				}
			})
			console.log(newARray2);
			
			//some 判定数组中是否存在某个符合条件的,返回值为布尔值; 一旦函数返回true那么some就会终止循环，并且返回true ;
			//而且一旦匹配成功，后面就不再遍历了，如果没有匹配成功，最后返回false可以用来做一些检测
			//some( function(item, index, arr){ })
			var arr4 = [15000,20000,21000,26000,3000,2000,8000];
			var booLean=arr4.some(function(item,index,arr){
				console.log(item);	
				return item=2000;
			})
			console.log(booLean);
			// 封装
			function mySome(arr,fn){
				for (var i=0;i<arr.length;i++) {
					if(fn(arr[i],i,arr)){
						return true;
					}
				}
				return false;
			}
			var booLean3=mySome(arr4,function(item,index){
					return item%5000===0;
			})
			console.log(booLean3);
			
			//every 判定数组中是否全部符合某个条件,返回值为布尔值;
			// 要求每一项都符合，才返回true有一项不合格就返回false
			// every( function(item, index, arr){ })
			var booLean1=arr4.every(function(item,index,arr){
				//console.log(item);
				return item%1000===0;
			})
			console.log(booLean1);
			// 封装
			function myEvery(arr,fn){
				for (var i=0;i<arr.length;i++) {
					if( !fn(arr[i],i,arr)){
						return false;
					}
				}
				return true;
			}
			var booLean2=myEvery(arr4,function(item,index){
					return item%2000===0;
			})
			console.log(booLean2);
			
			//reduce 归并  逐个求和,归并为一个  返回值是之前的所有的结果
			// 之前的处理结果及下一个元素,逐个归并
			// reduce( function(pre, next, index, arr){ })
			var arr5=[1,2,3,4,5];
			var res5=arr5.reduce(function(pre,next,index,arr){
				//console.log(pre,next,index);
				return pre+next;
			})
			console.log(res5);
			// 封装
			function myReduce(arr,fn){
				var preRes=arr[0];
				for (var i=0;i<arr.length;i++) {
					preRes=fn(preRes,arr[i],i,arr);
				}
				return preRes;
			}
			var Res5=myReduce(["a",2.3,"%",false,undefined,null,9],function(pre,next,index,arr){
				return pre+next;
			})
			console.log(Res5);
		</script>
	</body>
</html>

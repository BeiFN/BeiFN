<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        //对象的扩展，扩展运算符
        var obj1 = {
            a :10,
            b :20,
            c :30,
        } 
        var obj2 = {
            d :10,
            e :20,
            f :30,
        }
        var obj3 = {
            ...obj1,
            ...obj2,
        }


        // 函数扩展，箭头函数

        function fn(a,b){
            return a+b;
        }
        console.log(fn(1,2));

        let fnn = (a,b) =>a+b;
        console.log(fnn(1,2));

        // 框架开发中，语法糖

        // 箭头函数和匿名函数极其相似
        // 形式基本一致，
        // 箭头函数，声明都是匿名的
        // (参数)=>{代码}
        // 变种简化写法
        // 一个参数，不加小括号  一个参数a =>{代码}
        // ()=>一行代码; 可省去大括号

        let foo = () => {
            console.log("hello workd");
        };
        foo();
// return 支持，this
        let foo1 = (a,b) => {
            return a+b;
        };
        foo1(1,2);//3

        // arguments 不支持
        let foo2 = (a,b) => {
            // console.log(arguments);
            return a+b;
        };
        foo2(1,2);//3

        // this 支持，箭头函数在创建时就已经确定了函数的this指向，this不会再随着调用者改变
        let foo4 = (a,b) => {
            console.log(this);
            return a+b;
        };
        foo4(1,2);//3


        // 箭头函数不能作用构造函数，不能使用new实例， 
        // 让函数更加纯粹，功能复用，不用函数再去构造实例
        // let Foo = ()=>{

        // }
        // //new Foo();//报错

            // 箭头函数，  只能作为函数的封装和复用的代码包裹使用了。
            // 是函数的部分替代品 ，因为在ES5及之前版本中，被设计的过于强大了

            // class 构造函数

            // 老版本：函数this指向根据调用者去决定
            // 新版本：函数声明时this指向哪里，函数的this就永远指向这里，而且不可更改

            let foo5 = () => {
                console.log(this);
            };
            foo5.call({name:"new"});
            // call 和apply失效了和bind都无效
            // 不给编辑this指向的权限了，按照既定规则走就行
            

            let foo6 = () => {
                console.log(this);
            };
            foo6();

            var obj = {
                foo : foo,
            }
            obj.foo();
            // 

            var obj1 = {a:10};
            // 解析器创造对象
            var obj1 = new Object();
            // 属性

            document.onclick = ()=>{
                console.log(this);//window
            }
            // 事件处理函数中，用this获取dom的方式会被逐渐淘汰
            // js中this指向逐渐统一，指向实例对象

        // 1.作为事件处理函数this,指向不固定指向触发元素的
        // 2.不能作为原型中的方法,应为this指向也是固定无法访问实例之中的属性
    </script>
</body>
</html>
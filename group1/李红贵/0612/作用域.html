<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>作用域</title>
</head>
<body>
    <script>
        // 作用域
        // js只有函数作用域

        // var a = 10;
        // console.log(a);

        // function foo(){
        //     // 1.在内存中开辟一块空间，用来存储foo函数运行需要用到的数据
        //     // 2.把局部变量a 放到当前空间，
        //     var a = 10;
        //     console.log(a);
        //     // 3.引用前在空间中取出相应的内容，然后使用
        // }
        // // 4.函数运行结束
        // // 内存有一个垃圾回收机制， 1.计算法，  2.标记法 
        // foo();
        // console.log(a);

        // 生命周期：全局变量生命周期是永久的，在程序任何位置都可以访问。
        // 局部变量生命周期是有限的，在作用域创建时被创建，在作用域被销毁时消失。

        // 作用范围有限的变量称为局部变量
        // 如果声明变量的时候，这个变量没有被函数包裹，那么这个变量是全局变量
        // 在任何位置可以访问全局变量

        // 全局变量
        // var a = 10;
        // 数据存储相对永久，相对程序永久，只要程序运行，全局变量就常驻于内存之中，程序占用内存恐惧较大
        // 尽量少用全局变量

        // 局部变量
        // 在函数中声明的变量叫局部变量

        // js的糟粕特性  js编译代码，先浏览代码（检查下面两方面是否有错误 1.浏览变量|函数的声明（），2.语法 ），再编译代码  
        // 声明提升：当在任何位置，编写一个变量声明的时候，当代码解析时，解析器会将这个变量的声明提升到当前域的最前列进行声明，在原位置保留赋值
        // 函数整体提升
        // 当操作全局变量的时候，我们赋值会影响全局变量
        // for()中声明的参数为全局变量
        // console.log(a);
        //  var a = 10;

        // 访问顺序
        // 就近原则，同名局部变量提升到程序顶端

        // 函数执行的时候，会产生一个作用域，变量声明时，会被解析器进行声明提升
        // 函数被调用时，创建执行环境，函数没有调用前，就是字符串
        // 当代码开始执行时，函数内部大括号中代码就是执行环境。
        // 变量对象：用来存储执行函数内部变量值，以键值对形式存储  活动对象是存储局部变量的

        function foo(){
            console.log(ha);
        }
        // 逐个作用域查询的机制  作用域链 作用域访问关系，顶层是widow

        

    </script>
</body>
</html>
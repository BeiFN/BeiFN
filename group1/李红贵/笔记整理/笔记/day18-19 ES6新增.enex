<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-export SYSTEM "http://xml.evernote.com/pub/evernote-export2.dtd">
<en-export export-date="20190708T084812Z" application="Evernote/Windows" version="6.x">
<note><title>day18-19 ES6新增</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">

<en-note><div><font style="font-size: 16pt;"><b>ES6新增</b></font></div><div><font style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;ES6是对ES5的扩展式更新，提供了一些疑难杂症解决方案，及异步解决方案等。ES6兼容性有一定问题，可以通过babel工具转ES5.</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><b>变量let</b></font></div><div><font style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用：</font></div><div><font style="font-size: 12pt;">作用域的创造更加自然了, 不再使用像是之前一样匿名函数作为作用域，而是使用 大括号直接作为作用域;</font></div><div><font style="font-size: 12pt;">减少匿名函数使用频率;</font></div><div><font style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;块级作用域{大括号作用域}</font></div><div><font style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TDZ，暂时性死区，阻止声明提升，在变量声明时，变量之前所有空间，不允许使用这个变量!&nbsp;&nbsp;在局部作用域中使用let声明的变量也存在局部暂时性死区，且访问规律和正常js机制一致。</font></div><div><font style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在同一作用域中，不允许重复声明同一变量。</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><b>常量const</b></font></div><div><font style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义之后不可以赋值。</font></div><div><font style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;常用来存地址，以及避免赋值被污染</font></div><div><font style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;唯一标志</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 14pt;"><b>解构赋值</b></font></div><div><font style="font-size: 12pt;"><b>数组赋值</b></font></div><div><font style="font-size: 12pt;">左右数组依次对应，声明变量并赋值</font></div><div><font style="font-size: 12pt;">let [a,b,c,d] = [1,2,3,4,5];</font></div><div><font style="font-size: 12pt;">声明变量abcd，并分别赋值为1234</font></div><div><font style="font-size: 12pt;">let [a,b,c,d] = [1,2,3];</font></div><div><font style="font-size: 12pt;">声明变量abcd，abc分别赋值123，d为空。</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt; color: rgb(26, 173, 224);">剩余运算符...</font></div><div><font style="font-size: 12pt;">let [a,b,c,[e,f],...d] = [1,2,3,[&quot;h&quot;,&quot;l&quot;],5,6,7,8,9];</font></div><div><font style="font-size: 12pt;">console.log(a,b,c,d,e,f);</font></div><div><font style="font-size: 12pt;">1 2 3 Array(5)0: 51: 62: 73: 84: 9length: 5__proto__: Array(0) &quot;h&quot; &quot;l&quot;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><b>对象赋值</b></font></div><div><font style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基本结构：对象结构要求左右两侧必须均为大括号，否则报错</font></div><div><font style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基本使用&nbsp;&nbsp;=左边 解构&nbsp;&nbsp;=右边对象</font></div><div><font style="font-size: 12pt;">let { a , b } = { a : 1 , b : 2};</font></div><div><font style="font-size: 12pt;">声明了变量 a 和 b , 并且给变量赋值为 对象.a 和 对象.b;</font></div><div><font style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let obj = { a : 10}</font></div><div><font style="font-size: 12pt;">let { a } = obj;</font></div><div><font style="font-size: 12pt;">//相当于 var a = obj.a;</font></div><div><font style="font-size: 12pt;">console.log(a);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;改名机制</b></font></div><div><font style="font-size: 12pt;">变量别名&nbsp;&nbsp;给 c 变量赋值 对象.a 的属性值;</font></div><div><font style="font-size: 12pt;">let { a : c , b } = { a : 1, b:2} ;</font></div><div><font style="font-size: 12pt;">console.log(c,b)</font></div><div><font style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// { 原有属性 : 新变量名 }</font></div><div><font style="font-size: 12pt;">let { slice : mySlice , concat } = Array.prototype;</font></div><div><font style="font-size: 12pt;">//第一个参数等价于 let mySlice = Array.prototype.slice;</font></div><div><font style="font-size: 12pt;">console.log(mySlice)</font></div><div><font style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认参数</font></div><div><font style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let { a = 10 , b = 20} = { b : 30 };</font></div><div><font style="font-size: 12pt;">// a = 10 , b= 20;//默认值</font></div><div><font style="font-size: 12pt;">// b = 30;//赋值</font></div><div><font style="font-size: 12pt;">console.log(a,b);// 10, 30</font></div><div><font style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function Foo( { effect = &quot;fade&quot; , pagination = &quot;.pagination&quot; } = {}){</font></div><div><font style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(effect,pagination);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">Foo(</font></div><div><font style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;// {effect : &quot;slide&quot;}</font></div><div><font style="font-size: 12pt;">)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 14pt; color: rgb(255, 0, 0);"><b>箭头函数</b></font></div><div><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;箭头函数是函数的部分替代品，只能作为函数的封装和复用的代码块包裹使用。</span></div><div><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和匿名函数极其相似，声明时都是匿名的</span></div><div><span style="font-size: 12pt;">标准写法&nbsp;&nbsp;(参数) =&gt; {代码};</span></div><div><span style="font-size: 12pt;">let fn = (a,b)=&gt;{return a+b;}</span></div><div><span style="font-size: 12pt;">箭头左边如果只有一个参数，那么可以省略左边小括号，如果右边只有一行代码，那么可以省略右边大括号</span></div><div><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;支持return，不支持arguments，不能作为构造函数，也能作为原型中的方法，因为this固定，不能指向实例中的方法。</span></div><div><span style="font-size: 12pt;">让函数变得更加纯粹</span></div><div><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所在作用域this指向谁，它里面的this就指向谁。</span></div><div><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JS老版本 : 函数的this指向根据调用者去决定;</span></div><div><span style="font-size: 12pt;">JS新版本 : 函数声明时this指向哪里函数的this就永远指向这里，而且*不可变*;</span></div><div><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call，apply bind都失效，不能改变箭头函数执向</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><b>模板引擎</b></span></div><div><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;模板引擎就是在写html时放入js逻辑</span></div><div><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字符串模板中的规则 :</span></div><div><span style="font-size: 12pt;">&lt;% 内部的代码是js逻辑 %&gt;</span></div><div><span style="font-size: 12pt;">未被包裹的是html拼接的字符串;</span></div><div><span style="font-size: 12pt;">使用${}进行拼接，使用``框表示字符串</span></div><div><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在script标签type为 text/html 的时候,作为一个承载 html + js混写的字符串的地方;内部的所有代码不会解析，只会当成字符串;&nbsp;&nbsp;</span></div><div><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字符串模板引擎就是将 js和html混编代码，进行字符串替换处理，转为可被解析器识别的HTML代码</span></div><div><span style="font-size: 12pt;"><b>&nbsp;&nbsp;&nbsp;&nbsp;特殊字符</b></span></div><div><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取超出4位ascii码字符</span></div><div><span style="font-size: 12pt;">var str = &quot;𠮷野家&quot;;</span></div><div><span style="font-size: 12pt;">console.log(str.codePointAt(0));</span></div><div><span style="font-size: 12pt;"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Symbol，符号类型</b>，每次创建都唯一</span></div><div style="min-height: 12pt; text-align: left;"><span style="min-height: 12pt; font-family: ΢���ź�;"><font style="font-size: 12pt;">1. 设置常量;</font></span></div><div style="min-height: 12pt; text-align: left;"><span style="min-height: 12pt; font-family: ΢���ź�;"><font style="font-size: 12pt;">防止和对象之前的key值冲突;</font></span></div><div style="min-height: 12pt; text-align: left;">```javascript</div><div style="min-height: 12pt; text-align: left;"><span style="min-height: 12pt; font-family: ΢���ź�;"><font style="font-size: 12pt;">const key = Symbol(&quot;key&quot;);</font></span></div><div style="min-height: 12pt; text-align: left;"><span style="min-height: 12pt; font-family: ΢���ź�;"><font style="font-size: 12pt;">let obj = {</font></span></div><div style="min-height: 12pt; text-align: left;"><span style="min-height: 12pt; font-family: ΢���ź�;"><font style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [key] : &quot;hello&quot;</font></span></div><div style="min-height: 12pt; text-align: left;"><span style="min-height: 12pt; font-family: ΢���ź�;"><font style="font-size: 12pt;">}</font></span></div><div style="min-height: 12pt; text-align: left;"><span style="min-height: 12pt; font-family: ΢���ź�;"><font style="font-size: 12pt;">console.log(obj);</font></span></div><div style="min-height: 12pt; text-align: left;"><span style="min-height: 12pt; font-family: ΢���ź�;"><font style="font-size: 12pt;">console.log(obj[key]);</font></span></div><div style="min-height: 12pt; text-align: left;"><span style="min-height: 12pt; font-family: ΢���ź�;"><font style="font-size: 12pt;">```</font></span></div><div><span style="font-size: 12pt;"><b>&nbsp;&nbsp;&nbsp;&nbsp;新增set，Map</b></span></div><div><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Map和set集合，存储为 值=&gt;值</span></div><div><span style="font-size: 12pt;">不允许存在重复元素，<font style="color: rgb(255, 0, 0);">Map元素可以为任意类型</font></span></div><div><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建set</span></div><div><span style="font-size: 12pt;">var set = new Set([2,3,4,5,2,6,7,8,9]);</span></div><div><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set.add(&quot;str1&quot;);添加元素</span></div><div><span style="font-size: 12pt;">&nbsp; &nbsp; &nbsp; &nbsp; set.delete(3);删除</span></div><div><span style="font-size: 12pt;">&nbsp; &nbsp; &nbsp; &nbsp; set.has(5);，判断是否存在</span></div><div><span style="font-size: 12pt;">&nbsp; &nbsp; &nbsp; &nbsp; set.entries();打印指向</span></div><div><span style="font-size: 12pt;"><span>&nbsp;&nbsp; &nbsp;</span><span>&nbsp;&nbsp; &nbsp;</span>set.clear(); 清空</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><b><font style="color: rgb(255, 0, 0); font-size: 14pt;">&nbsp;&nbsp;&nbsp;&nbsp;class</font></b></div><div><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类，构造函数+原型</span></div><div><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;加载class内部的方法，相对于添加原型方法</span></div><div><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class中加固定写法函数，constructor相当于构造函数</span></div><div><span style="font-size: 12pt;"><font color="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;&nbsp;使用 static width；</font></span></div><div><span style="font-size: 12pt;"><font color="#FF0000">class P{static width;}中的静态资源，相当于class的属性，可以被外部用构造函数P.width,调用里面存的数据</font></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div></en-note>]]></content><created>20190708T022718Z</created><updated>20190708T025513Z</updated><note-attributes><author>【千锋互联】JS高级讲师--尹涛</author><source>desktop.win</source><source-application>evernote.win32</source-application><reminder-order>20161202T051649Z</reminder-order></note-attributes></note></en-export>

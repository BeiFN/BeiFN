
##第一周

## 1.什么空心菱形，当网页翻译成中文时，右边的腰会偏向左边？
方法：在控制台查看是谁影响了布局，结构或者样式。
结论 :  但浏览器翻译的时候，会给每个字符加上一个font标签，导致原始布局失效。

## 问题2  变量会覆盖函数吗？
![image.png](https://upload-images.jianshu.io/upload_images/2845301-125deab192d2ef44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

解决思路：考虑就近原则

##同类问题  同名全局变量和局部变量，哪个优先级最高？   
就近原则 :  对变量访问的时候，才会考虑优先级问题。


## 问题3  使用运算符立即执行的匿名函数，可以在function后的（）中传参数吗？

可以 ; 传全局变量。


## 问题4   构造函数方法创建对象时，能不能在声明直接赋值
![问题截图](https://upload-images.jianshu.io/upload_images/12728563-c3a6810eca630794.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

解决思路：查看官方文档
[Object文档链接](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object)

答案：可以在创建时初始化对象
```
    var obj3 = new Object({"a":3,"b":"string"});
	console.log(obj3);
    
```


## 问题5  下图结构思路不明白

![问题截图2](https://upload-images.jianshu.io/upload_images/12728563-2a85bff28d5c43ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```javascript
      function foo(a){
            return function(b){
                  return function(c){
                        return function(d){
                              console.log(a + b + c + d);
                        }
                  }
            }
      }
      //foo();//  返回值是什么 ?  是内部 return 的匿名函数;
      // 一个函数执行结束之后，那么留在原地的程序所代表的值，就是他自己的返回值。
      foo(1)(2)(3)(4)

    //总结   单个方法名为引用类型；  加括号为调用，是运行结果
```


## 问题6   var a之后，为什么a in window 和 "a" in window 得到的结果都是true，二者有什么区别吗

![问题截图3](https://upload-images.jianshu.io/upload_images/12728563-b5e367a7a0fa5cf4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

>  in 关键字: 判定某个属性是否存在于对象之中。
>  "a"  in  window;  window之中是否存在a属性;

> var a = "xx";
> a in window 表示a所对应的值"xx"，是不是window的属性
>等价于  "xx" in window

**属性** 对象之中的key;
**变量** 使用var声明的;

> 声明全局变量时, 就想相当于 给 window 添加一个变量名的属性;
> var b = 10;     window.b = 10;
> "b" in window // true;



###第二周

##问题7  为什么定时器方法，传入参数在内部会变成undefined，setInterval( countDown(arr) , 1000 );

![image.png](https://upload-images.jianshu.io/upload_images/2845301-7b9b461cf8668fae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

>解决思路
> 定时器使用原则 : 传入的函数由浏览器帮忙调用。
>  document.onclick = fn();
```javascript
      setInterval(countDown(arr) , 1000)
      // countDown是不是已经被调用了 ? 
      // 定时器调用的是啥 ?
```
>定时器和函数触发事件赋值，都应该是传函数名即可，带括号则表示函数已经运行，再赋值是把运行结果赋值给对应事件。导致异常发生。


##问题8  为啥中间用的是：  显示出来是文字时分秒?

![image.png](https://upload-images.jianshu.io/upload_images/2845301-d23cdde08e13941d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* 未解之谜 
猜测可能是浏览器翻译问题。

##问题9  存储定时器的变量，先赋值为null是用来干嘛的？

![image.png](https://upload-images.jianshu.io/upload_images/2845301-1989e81f134cc416.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

> 两者区别不大;方便给定时器变量添加注释，避免undefined产生。


##问题10  回到顶部按钮，用style.cssText正常，把cssText里面代码分开，分条属性设置后，定住后，再往上滚动，不会再固定在屏幕上，是受哪个属性影响？
![image.png](https://images.gitee.com/uploads/images/2019/0621/080642_5327c136_5067933.png)

> 我们为了删除掉某些存在于元素上的行内样式 ; 这样的方式非常的不优雅。 
> 应该把属性放在class里面，js只操作元素的class增删，不对这么多的属性进行同时的增删改查, 会把样式放进行为之中。

总结：style.cssText会清除之前所有样式
把cssText里面代码分开，则之前设置的top属性值仍然存在，只是修改它的值也会影响布局。

##问题11  怎么获取某一个div的滚动超出部分？
![image.png](https://images.gitee.com/uploads/images/2019/0621/080642_e4b0979e_5067933.png)
> 案例中见;
li.scrollIntoView();直接将li显示在父标签底部


##问题12  为什么密码强度那个题目  script 标签中 没有声明body中 pwd_level_tip 也可以运行
![image.png](https://upload-images.jianshu.io/upload_images/2845301-6d2e9a5f0107fc8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

> H5新规 ID可以直接当成dom对象 ; ID值即为全局变量;
> JavaScript 是一个解释型语言 ; 会自动对代码进行一些小的改变;


##问题13   为什么有时候getAttribute()得不到属性的属性值,输出的属性值都是null,必须使用getComputedStyle()才行. 
![QQ截图20190621084551.jpg](https://upload-images.jianshu.io/upload_images/2845301-6f3a485c2731e064.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

思路：API理解记忆
> getAttribute =获取属性> <div class="box">
> getComputedStyle()  =获取样式 >  <div style="display:block">



####第三周
##问题14  box.createAttribute("test");和this.createAttribute(key);的差别在哪？我的理解this指向的就是box，为什么第一个方法会报错，而第二个是正常的？

```javascript
<body>
        <div id="box0" data-id="hello">
                <span>hello world</span>
               
                <!-- i'm comment  -->
        </div>
    <script>

        var box = document.getElementById("box0");

        // var test = box.createAttribute("test");
        // test.nodeValue = "testValue1";
        // console.log(box);
        /*
        attribute.html:19 Uncaught TypeError: box.createAttribute is not a function
        at attribute.html:19
        */

        function setAttribute(key,value){
			var myAttr = this.createAttribute(key);
			myAttr.nodeValue = value;


            // var test1 = document.createAttribute(key);
		    // test1.nodeValue = value1;
		    // this.setAttributeNode(test1);
		    // console.log(box);
		}
        box.setAttribute("test1","lulizhong1");
        // box.setAttribute("test2","lulizhong2");
        console.log(box);

     
    </script>
</body>

```

思路：自定义方法和系统方法同名，后面调用的是系统方法，而不是自己定义的方法。  第二个正常是错觉。
createAttribute方法使用是固定为：document.createAttribute("key");
只可以修改括号内的key值


##问题15 外部函数的变量timer是否被内部函数引用？外部函数被调用时，内部函数是否立即执行，是否构成了闭包？timer赋值null后，数据被清空，timer这个变量是否还在？
   ![image.png]https://upload-images.jianshu.io/upload_images/18429017-2a03b77d346fdfd5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240
>垃圾回收机制,
>函数内声明变量时添加回收标志，
>被引用时清空回收标志，
>置空时添加回收标志

解题思路：该定时器置空时会在之后被自动回收，但是在move方法中，会继续创建下一个定时器，一直创建再清空。



##问题16 两种创建节点的区别

添加属性节点
方法一:
var myAttr = document.createAttribute("data-hello");
myAttr.nodeValue = "helloWorld";
box.setAttributeNode(myAttr);
方法二:
box.setAttribute("data-hello","helloworld");

添加文本节点
方法一：
var textNode = document.createTextNode("hello world");
box.appendChild(textNode);
方法二：
box.innerHTML = "hello world"
box.innerText = "hello world" 

>思路：实现效果相同，只是实现方法不同，一种是调用系统封装方法，一种是自己封装的方法。自己封装的方法，可能比系统方法更优秀，可能性能会稍微好一点，到效果有限。在追求极限性能时，可以自己封装，平时用系统方法就行。自己封装方法，只是为了方便理解学习。


## 问题17:跳转页面时，什么时候用open(),什么时候用location.href = ""；
* location.href   原页面改变
* open            打开新页面;
>根据需求定


## 问题18:  bind指向对象传false该怎么理解？是说它不固定指向吗？
* 传入 false 就是不改变 this 指向。固定指向false，不能再指向事件源


## 问题19: 事件委托封装里的创建按钮函数里传不传参数e,有什么区别和影响吗？啥时候该传，啥时候不用传？

![image.png](https://upload-images.jianshu.io/upload_images/12728563-ac3ff12e234d0226.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

>思路：需要使用事件对象时传入，不需要使用事件对象即可不传入


## 问题20: 正则表达式中的全局修饰符g和贪婪匹配的关系，有全局修饰符，一定是贪婪吗？  
>思路：两者是不同的，没有必然关系，贪婪存在于单次匹配中，g决定匹配次数。
> 贪婪      是和量词有关的。  +  *  ?  
> 尽可能多的匹配符合规则的字符。   一次尽可能匹配更多;
> 修饰符 g  驱动方法多次匹配;      在整条字符串上多次进行匹配;


## 问题21： 提问在图中 代码如下

![image.png](https://upload-images.jianshu.io/upload_images/12728563-ebac1f33e890622d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```javascript
			var arr = [[1,2,3,4,5],[3,4,5,6,7],5,6];
			function flat(arr){
				// if(!flat.res){
				if(arguments.length === 1){
					flat.res = [];
				}

<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		<script type="text/javascript">
			var arr = [[1,2,3,4,5],[3,4,5,6,7],5,6];
			function flat(arr){
				if(!flat.res){
					flat.res = [];
				}
				
				for(var i = 0 ; i<arr.length;i++){
					if( !(arr[i] instanceof Array) ){
						flat.res.push(arr[i]);
					}else{
						flat(arr[i] , false);
						flat(arr[i]);
					}
				}
				return flat.res;
			}	
			var arr2 = [1,2,3,4]
			console.log(flat(arr));
			console.log(flat(arr2));
```

* 递归时我们去进行区分，是外部调用 ; 还是内部递归用。 根据两种情况进行区分操作。
  
		</script>


## 问题22: 智哥，问两个 VScode的快捷键。  超出可视区域的代码或者注释 是怎么自动换行的？  怎么同时选中相同的函数名一起修改？
>解决思路：百度
* ALT + Z 
* CTRL + D


## 问题23  智哥，replace()如何替换多个内容，比如我能在输入框里一下子输入 ：术语、正则，然后替换吗？

* 匹配到了更多内容。 => 规则允许更多内容; 
* 把规则写好，写全那么replace 会自动帮你进行匹配的;

var reg = /术语|正则/g; 

![QQ截图20190629081155.png](https://upload-im
ages.jianshu.io/upload_images/14040632-322f62a373dfaefd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* 组 : 在正则表达式中 `()` 代表组 , 你在后面进行使用的时候 可以用 $n 去替代 , n是怎么去赋值的那 ? 从左到右第一个组为1(第一个括号之中的内容)


## 问题24 在高级查找中，再次查找前如何清除清除上次查找到的高光标记？？？

>思路：清除标签
```javascript

      var regSpan = /<\/?span>/g;
      content.innerHTML = contentText.replace(nowReg  , "");

```

##问题 25 为什么要在表单验证里的匿名函数传入window对象,有什么作用? 我试过,不传window也行.

>目的
* 减少原型链访问的次数,优化性能; 我们只会传window , 或者jQuery 。

>1.全局变量，可以直接在函数内部获取 
>2.如果不考虑方便性，所有形参都可以省略，直接从arguments里面获取.
>3.如果只传形参window，不传实参会报错，往undefined里面传方法报错。



####第四周问题整理

##问题 26 给重力回弹小球添如下居中代码，
left: 50%;
margin-left: -20px; 
再使用 ball.style.left = ball.offsetLeft + speedX + "px";  
为什么设置偏移量时，会有20px速度的偏差，相当speedX加了个往左20px的速度。
margin-left属性和 offsetLeft属性有冲突吗？

>解决思路：获取offset值时，获取方式是先从界面中拿出目标元素，测量完再放回去。当margin-left为-20时，offset测量时多了往左的20px，，所以每次赋值时都多了20，相当往左的速度加了20px。


#问题27：下面代码，按键控制盒子移动，为什么键盘持续按下的时候会先走30px，然后停顿0.5s后连贯移动，怎么回事？
>解决思路：持续按下0.5s后才算长按，是受系统本身机制影响，键盘按下0.5s后才算长按，由系统机制决定，无法修改。


##问题28： 小球速度损耗的问题,每次小球下降到底部时,速度会少加一次g,因此理论上速度损耗为g的值,但是当把g设置成带小数的值的时候,速度损耗有时看起来没有规律,是浏览器识别的最小单位为1的缘故吗?请智哥分析一波
![重力小球.png](https://upload-images.jianshu.io/upload_images/18487325-a378dede0f4f21f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
>思路 
>重力加速运动流程：
1.速度加速度g恒定
2.当距离目标间距小于速度时，判定为到达底部，将其定在底部
3.到达底部时，速度取反，继续向上减速运动，到达顶点速度为0，受加速度影响，重复向下运动流程。
4.当速度大于于负加速度（-g）时，运动结束

保证每次弹上去的距离小于前一次距离的操作是步骤2，每次定在底部时最多减少了最大下落速度的距离。
保证停止的条件是，速度大于负加速度，落下时速度增加到最大，取反，速度大于-g则最接近停止。


## 问题29: 烟花程序中，Firework.prototype.fireworkBoom函数里的下段代码里的false不太理解，请智哥再讲解一下缘由。
![QQ截图20190702075026.png](https://upload-images.jianshu.io/upload_images/2845301-f40f51658e80023b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* bind(this,arg1)  => 生成一个新函数 => 包含了 fire_boom 元素的引用;
* 因此可以在运动结束后让元素进行删除。


##问题30  原型链的调用顺序没弄明白，请指教。

* 构造函数  
* 原型对象
* 实例对象

- 构造函数 和 原型对象之间的关系   伴生
  
  ```javascript
    function Foo(){}
    // 当一个函数出现的时候，JS会默认给他搭配一个原型对象;
    Foo.prototype
  ```

- 构造函数 和 实例对象之间的关系   创造  
  ```javascript 
    var instance  = new Foo();
    //   实例           构造函数;
  ```

- 原型对象和实例      指向
  ```javascript
    Foo.prototype => 用来储存数据,储存方法的地方

    var instace = new Foo();

    instance => {
        constructor : Foo ,         // 构造函数指针;
        __proto__   : Foo.prototype // 构造函数原型指针;
    }
  ```

* 最终目标 : 一套方法 可以重复使用,不需要多次声明。

* => 所有的方法都放在原型之中 ; 
*    实例就可以共享所有的方法了; 
*    有一个大的类别 : String | Array | Object | Number | Function | .....
*    [].forEach() 
*    所有的对象都有原型指针 => 因为所有的对象都来自构造函数;

* 面向对象编程 
* 需要一个对象 , {} × new Foo() √;
* Foo{} => 自定义实例对象 ;
```javascript
{
    constructor : Foo,
    __proto__ : Foo.prototype
}
Foo{}.a 

// 1. 在 实例对象 Foo{} 里面查看是否存在 a 属性 , 如果存在返回结果 ,如果不存在沿着 __proto__ 去进行找寻。
// 2. Foo.prototype 里面查看是否存在 a 的属性, 同上
// 3. Object.prototype 里面查看是否存放  a 的属性。

```

##问题31  new*创造*新对象,赋值给table1 , table1为实例 , 怎么理解构造函数中的this指向实例 table1 , table1不是存的是地址!;

```javascript
    // 创建实例table1
    // 可以理解为 table1调用new Table();方法吗？
    var table1 = new Table("btn-list", "content-list");

    // 1.  构造函数创建实例;

    // 如何得到实例  : 
    // ① 构造函数的返回值;
    // ② 构造函数中的this;
```


##问题32 实例调用原型的init属性方法的流程是什么样的？原型是构造函数的原型，还是实例的原型？
* 实例 | this => 访问init => 实例中没有 => 沿着原型链向上找寻 => 找到原型上的init => 得到访问结果;



##问题33  如下注释的理解正确吗？ 请大家帮忙找出理解错误的地方。
```javascript
// 构造函数创建
        function Table(btnSe, contSe){
            // this是指向实例对象，使用Table构造的对象，即 Table{} ,
            // 给实例对象添加btns属性，存放所有目标元素
            this.btns = document.getElementById(btnSe).children;
            this.conts = document.getElementById(contSe).children;
        }
        // 原型添加方法属性, 初始化init, 实例调用初始化方法
        // table1.init(); table1调用了init方法，所以init方法里面this指向实例table1 √;
        Table.prototype.init = function(){
            // 从实例对象中获取目标元素添加绑定事件，并让this指向实例对象
            for(var i=0,btn; btn= this.btns[i];i++){

                // btn.addEventListener("click",this.handlerContent);
                // 面向对象编程中所有的函数内部this指向都指向实例对象 √;

                btn.addEventListener("click",this.handlerContent.bind(this,i));
                // 实例对象中的目标元素，调用原型的属性方法，并使用bind方法将指向btn的指针this指向实例

                btn.addEventListener("click",this.changeColor.bind(this,i));
            }
        }
        // 给原型对象添加事件处理方法属性，在绑定事件时固定了this指向，所以下方法中this指向实例table1
        Table.prototype.handlerContent = function(index,evt){
            var e = evt ||window.event;
            var target = e.target ||e.srcElement;
            for(var i=0,cont; cont = this.conts[i++];){
                cont.className = "";
            }
            this.conts[index].className = "active";

        }

        Table.prototype.changeColor = function(index,evt){
            var btn = this.btns[index];
            btn.style.backgroundColor = "#"+Math.round(parseInt("ffffff",16)*Math.random()).toString(16).padStart(6,"0");
      
        }

        //构 建函数方法使用
        // 创建实例table1

        //可以理解为 table1 调用new Table();方法吗？ × 
        // 你调用的 Table 不是table1;
        var table1 = new Table("btn-list", "content-list");
        table1.init();
```
>思路 记住构造函数，原型和实例的关系，明白原型链的调用顺序。


## 问题34: 轮播图从5到1后，点击页码往左滚动bug，如何修复？
>思路，可复现bug，根据情况，添加特殊情况特殊处理。
```javascript
    /**
 * 实现的目标 :
 *    1. 点击按钮翻页;
 *    2. 点击分页器翻页;
 *    3. 多种动画效果;
 *    4. 自动播放;
 *  */

 // 程序之中必须要有 ,表示当前显示图片的坐标;  nowIndex;
 // 下一页 上一页 到达某页;

 // 1. 得有元素绑定事件 ;

 // 2. options => effect : fade | slide 
 //    1. 影响基础布局;
 //    2. 影响动画效果;


 Banner.prototype.toIndex = function(index){

      // 显示为假的第一张,点击真的第一张; 
      if(this.nowIndex === this.sliders.length - 1 && index == 0){
            return false;
      }
       
      this.nowIndex = index;
      // 显示为假的第一张 ,点击其他的内容;
      if(this.nowIndex !== 0 && this.nowIndex === this.sliders.length - 1){
            this.state = "changePage";
      }else{
            this.state = "normal";
      }
      
 }
 Banner.prototype.slide = function(){
     // 动画特殊处理 => toIndex 动画; 
      if(this.state === "changePage"){
            this.wrapper.style.left = 0;
            this.wrapper.style.transition = "top 1s";
      }
      switch(this.state){
            // 增加BUG解决动画;
            case "changePage":
                  setTimeout(function(){
                        this.wrapper.style.transition = "left 1s";
                        this.wrapper.style.left = -this.nowIndex * this.main.offsetWidth + "px"
                  }.bind(this) ,0) 
                  break;
            case "normal" : 
                  this.wrapper.style.left = 0;
                  this.wrapper.style.transition = "left 1s";
                  setTimeout(function(){
                        this.wrapper.style.left = -this.nowIndex * this.main.offsetWidth + "px"
                  }.bind(this) , 0) 
                  break;
            case "changeFirst":
                  this.wrapper.style.transition = "top 1s";
                  this.wrapper.style.left = 0;
                  setTimeout(function(){
                        this.nowIndex ++;
                        this.state = "normal";
                        this.slide();
                  }.bind(this),0);
                  break;
            case "changeLast" :
                  this.wrapper.style.transition = "top 1s";
                  this.wrapper.style.left = -(this.sliders.length - 1)* this.main.offsetWidth + "px";
                  setTimeout(function(){
                        this.nowIndex --;
                        this.state = "normal";
                        this.slide();
                  }.bind(this),0)
      }

 }

```


##问题35  为什么第一次点击左侧按钮打印不出0，也就是为啥第一次进不去if判断？
![image.png](https://upload-images.jianshu.io/upload_images/2845301-d3f1b315c2fb8968.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```javascript
    后面有操作index的for循环删除掉就好了;
```


## 问题36: 第二个let声明的i不是只在块级块级作用域里有效吗? 可不可以认为是for循环里构成闭包了，内部引用了i ，所以一直都存在?
>for循环小括号作用域是后面大括号作用域的外层作用域，for里面使用let声明变量时，大括号中引用该变量，构成了闭包。
* 理解正确;
```javascript
      var a =[];
      for(var i = 0; i<10;i++){
            a[i] = function(){
                  console.log(i);
            };
      }
      a[2]();
      console.log(a);
      console.log(a[2]) ;

      var a =[];
      for(let i = 0; i<10;i++){
            a[i] = function(){
                  console.log(i);
            };
      }
      a[2]();
      console.log(a)
      console.log(a[2]) ;
```


##问题37 京东的小图标怎么获取？
可以在 Iconfont-阿里巴巴矢量图标库 官网 下载使用图标。
* iconfont
* 

## 问题38: class的默认参数怎么设置与使用呢？ 
>使用如下：
```javascript
constructor({small_wrapper = ".small-img"}={}）{
    this.small_wrapper = static $(small_wrapper); 
}
```
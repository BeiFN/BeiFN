### 1.什么空心菱形，当网页翻译成中文时，右边的腰会偏向左边？

浏览器是产品: 翻译成中文的时候 。  谁影响了布局 ? 结构 , 样式。
结论 :  但浏览器翻译的时候，会给每个字符加上一个font标签，导致原始布局失效。
### 2 问题

```
    VM223:1 Uncaught SyntaxError: Unexpected number
        at test (jsq.html:81)
    at HTMLInputElement.onclick (jsq.html:58)
```

解决 : 添加了问题汇总, 多了一个错误总结。
### 3zcool网站里图片用超链接是啥意思？是保存网站里的图片直接用吗？怎么是叫做网站里的图片用超链接？

1. 线上网站 img 标签直接复制图片地址，直接应用
2. 背景图 , 找到背景图，然后open in new tab

###4讲一下第一天 表单和计算器那个题目**
讲完事件讲, 6.12案例;

###5变量覆盖函数吗？

https://upload-images.jianshu.io/upload_images/12728563-31de59d527d545ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240

###6使用运算符立即执行的匿名函数，可以在function后的（）中传参数吗？
可以 ; 
###7同名全局变量和局部变量，哪个优先级最高？ 
  
就近原则 :  对变量访问的时候，才会考虑优先级问题。







###8 构造函数方法创建对象时，能不能在声明直接赋值
![问题截图](https://upload-images.jianshu.io/upload_images/12728563-c3a6810eca630794.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

[Object文档链接](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object)

###9 下图结构思路不明白

![问题截图2](https://upload-images.jianshu.io/upload_images/12728563-2a85bff28d5c43ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```javascript
      function foo(a){
            return function(b){
                  return function(c){
                        return function(d){
                              console.log(a + b + c + d);
                        }
                  }
            }
      }
      //foo();//  返回值是什么 ?  是内部 return 的匿名函数;
      // 一个函数执行结束之后，那么留在原地的程序所代表的值，就是他自己的返回值。
      foo(1)(2)(3)(4)
```

###10 var a之后，为什么a in window 和 "a" in window 得到的结果都是true，二者有什么区别吗

![问题截图3](https://upload-images.jianshu.io/upload_images/12728563-b5e367a7a0fa5cf4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

> in 关键字: 判定某个属性是否存在于对象之中。
> "a"  in  window;  window之中是否存在a属性;

**属性** 对象之中的key;
**变量** 使用var声明的;

> 声明全局变量时, 就想相当于 给 window 添加一个变量名的属性;
> var b = 10;     window.b = 10;
> "b" in window // true;

 



###11 为什么定时器方法，传入参数在内部会变成undefined，setInterval( countDown(arr) , 1000 );

> 定时器使用原则 : 传入的函数由浏览器帮忙调用。
> document.onclick = fn();

```javascript
      setInterval(countDown(arr) , 1000)
      // countDown是不是已经被调用了 ? 
      // 定时器调用的是啥 ?
```

![image.png](https://upload-images.jianshu.io/upload_images/2845301-7b9b461cf8668fae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

###12为啥中间用的是:显示出来是文字时分秒?

![image.png](https://upload-images.jianshu.io/upload_images/2845301-d23cdde08e13941d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

- 未解之谜 ???

###13存储定时器的变量，先赋值为null是用来干嘛的？

![image.png](https://upload-images.jianshu.io/upload_images/2845301-1989e81f134cc416.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

> 两者区别不大;

###14第五单元案例，伪随机算法那道题的答案表达的是什么意思？

> 这是另外一个题目 : 题目描述根据相应的暴击率计算两人pk相互之间的伤害值。


###15回到顶部按钮，用style.cssText正常，把cssText里面代码分开，分条属性设置后，定住后，再往上滚动，不会再固定在屏幕上，是受哪个属性影响？

![image.png](https://images.gitee.com/uploads/images/2019/0621/080642_5327c136_5067933.png)

> 我们为了删除掉某些存在于元素上的行内样式 ; 这样的方式非常的不优雅。 
> 应该把属性放在class里面，js只操作元素的class增删，不对这么多的属性进行同时的增删改查, 会把样式放进行为之中。

###16怎么获取某一个div的滚动超出部分？

![image.png](https://images.gitee.com/uploads/images/2019/0621/080642_e4b0979e_5067933.png)

> 案例中见;

###19为什么有时候getAttribute()得不到属性的属性值,输出的属性值都是null,必须使用getComputedStyle()才行. 

> 好好看看API   
> getAttribute =获取属性> <div class="box">
> getComputedStyle()  =获取样式 >  <div style="display:block">

![QQ截图20190621084551.jpg](https://upload-images.jianshu.io/upload_images/2845301-6f3a485c2731e064.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

###20为什么密码强度那个题目  script 标签中 没有声明body中 pwd_level_tip 也可以运行

![image.png](https://upload-images.jianshu.io/upload_images/2845301-6d2e9a5f0107fc8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

> H5新规 ID可以直接当成dom对象 ; ID值即为全局变量;
> JavaScript 是一个


1 问题 ：通过循环生成顺序为一个 5×5 的二维数组 a 赋 1 到 25 的自然数，然后输出该数组的左下半三角。试编程。

```javascript
var a = [];
var b = [];
for (var i = 1; i <= 25; i++) {
  b.push(i);
  if (i % 5 == 0) {
    a.push(b);
    b = new Array();
  }
}
console.log(a);
for (var m = 0; m < 5; m++) {
  for (var n = 0; n <= m; n++) {
    document.write(a[m][n]);
  }
  document.write("<br>");
}
```

2 问题：如何求不确定位数的数，每个位数的值;

![](https://upload-images.jianshu.io/upload_images/18300474-81df65f268b3eb9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```javascript
var ran = parseInt(Math.random() * 10000);
var count = 0;
function foo(num) {
  if (num >= 1) console.log(num % 10);
  num = parseInt(num / 10);
  count++;
  if (num < 1) {
    console.log(count);
    return;
  }
  foo(num);
}
foo(ran);
```

3 function foo(){
​ console.log("a");
}
btn.onclick = foo();
（上面有 button 点击按钮） 但是这样写点击时 不能执行函数 在页面每次加载时会执行函数是为什么呢？

好好听课少年!;

4 问题 ：var a = null;
console.log(a instanceof Object)
console.log(typeof a)

为什么 typeOf null 是 Object 而 null instansof Object 为 false？
为什么 typeof null 是 Object 而 null instansof Object 为 false？
![](https://upload-images.jianshu.io/upload_images/18300474-e809b1b293e29163.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

> 语言本身的 bug ， null 是表示空的独立类型。
>
> 1. null 属于 object 类型;
> 2. null 不可能被 Object 构造函数构建;

5 构造函数和普通函数有啥区别 ;

> 构造函数是 new 调用的，普通函数直接调用。

6 问题 ：案例字符串过滤、用户名密码格式要求、三角函数曲线图不会做。

> 见案例

7 问题一：var targetTime = targetDate.setSeconds(0);这个方法怎么会是获取毫秒数，不懂。
![](https://upload-images.jianshu.io/upload_images/18300474-34a9170ac971381b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

> API 记忆 :
> Date 方法的 set 系列 API, 返回值是什么 ?
> 1970,1,1 ~ 设定的时间的毫秒数;

8 案例的聊天窗口不会做

> 稍后案例中见;

9 ![](https://upload-images.jianshu.io/upload_images/18300474-6a4addceb599c247.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

> dom.style.css 属性名 = 属性值;
> dom.style.cssText = "css 行内样式字符串";



###10 回到顶部按钮，用style.cssText正常，把cssText里面代码分开，分条属性设置后，定住后，再往上滚动，不会再固定在屏幕上，是受哪个属性影响？
![image.png](https://images.gitee.com/uploads/images/2019/0621/080642_5327c136_5067933.png)
> 我们为了删除掉某些存在于元素上的行内样式 ; 这样的方式非常的不优雅。 
> 应该把属性放在class里面，js只操作元素的class增删，不对这么多的属性进行同时的增删改查, 会把样式放进行为之中。


###11 怎么获取某一个div的滚动超出部分？
>运用新的API  元素.scrollIntoView();


###12 为什么有时候getAttribute()得不到属性的属性值,输出的属性值都是null,必须使用getComputedStyle()才行. 
![QQ截图20190621084551.jpg](https://upload-images.jianshu.io/upload_images/2845301-6f3a485c2731e064.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
> 好好看看API   
> getAttribute =获取属性> <div class="box">
> getComputedStyle()  =获取样式 >  <div style="display:block">


###13 为什么密码强度那个题目  script 标签中 没有声明body中 pwd_level_tip 也可以运行
![image.png](https://upload-images.jianshu.io/upload_images/2845301-6d2e9a5f0107fc8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
> H5新规 ID可以直接当成dom对象 ; ID值即为全局变量;
> JavaScript 是一个解释型的语言,无论将script标签写到哪里,解析完都会放到body里。


###14 闭包出现的内存泄漏问题应该如何解决？
> 控制一定的泄漏数量。 避免内存泄漏程序放在大型循环之中就可以了。


###15 页面加载时，进度条是根据什么获得到底加载了多少百分比的？
> 1. ajax加载;  => 数据加载 ;   1. total 总数 : loaded 已经下载的数量;
>    带宽 , 网速;
> 2. 宽度的比值 ;    盒子 100 px / 条 20; 


###16 如果一个div固定了宽高，改变div之内的字体大小，会引发回流吗？
> 分情况;
> 回流重建DOM树: 
>     1. GUI => 重新渲染元素排列;  DOM树描述的是层级结构关系。
>     2. 虚拟DOM => diff => 重构局部DOM树进行重新渲染;


###17 onmouseover/onmouseout和onmouseenter/onmouseleave这两组有什么区别?
   > mouseover 会重复触发子集事件;
   > mouseenter 不会;
   > 一组一组用 ! 


###18 下面的写法是什么意思？
```javascript
   (function(){ 
       ...
   }());
//解决：
   (function(){alert("我是匿名立即函数的一种写法, 外面的括号让我变成了一种计算")}())
```


###19 如何给一个元素添加多个事件(处理函数???)？
> addEventListener
>可以添加多个事件，添加的事件不会覆盖已存在的事件。第一个参数是事件，第二个参数是函数
>document.getElementById("myBtn").addEventListener("click", myFunction); 
>document.getElementById("myBtn").addEventListener("click", someOtherFunction);


###20 下面程序的执行结果
```javascript
   var a = 10; // 全局变量 a;  window.a = 10;
   var obj = {
       a: 20,  // obj.a == 20;
       b: function () {
           console.log(this) // obj;
           setTimeout(function () {
               console.log(this.a); // window   ==> window.a
           }, 0)
       },
       c: function () {
           console.log(this.a); //obj
       }
   }
   obj.b(); //10;
   obj.c(); //20;
   //为什么？
```
> 就近原则;   =>  this指向只看最近的一个函数;


###20（上面有button点击按钮）  但是这样写点击时 不能执行函数 在页面每次加载时会执行函数是为什么呢？
function foo(){
  ​  console.log("a");
 }
 btn.onclick = foo();
 解决：
>正确写法： btn.onclick=foo;   好好听课少年!;


###21 为什么typeOf null 是Object  而null instansof  Object 为false？
```javascript
  var a = null;
  console.log(a instanceof Object) 
  console.log(typeof a)
```
> 语言本身的bug ， null 是表示空的独立类型。  
> 1. null 属于object类型;
> 2. null 不可能被 Object 构造函数构建;


###22 构造函数和普通函数有啥区别？ 
>构造函数是new调用的，普通函数直接调用。


###23 var targetTime = targetDate.setSeconds(0);这个方法怎么会是获取毫秒数，不懂。
> API 记忆 : 
>           Date 方法的 set 系列API, 返回值是什么 ? 
>           1970,1,1 ~ 设定的时间的毫秒数;


###24  this指向的是li  ,为什么用li.className = "active"不行
![image.png](https://upload-images.jianshu.io/upload_images/18300474-e7e6e1a6c9f39373.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
解决：
>this指向的每一个当前的li元素, 而li.className的li是全局变量,最终会报错;


###25程序报错
![image.png](https://upload-images.jianshu.io/upload_images/18300474-6a4addceb599c247.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
>dom.style.css属性名 = 属性值;
>dom.style.cssText = "css行内样式字符串";

###26for循环可以遍历对象吗？
>不可以;因为单个对象没有length属性

###27用 for in 遍历对象时为什么用中括号取值而不用点取属性值。取属性值时哪种情况用点，哪种情况用中括号。
```javascript
    var obj = { a : 10 , b : 20}
    for(var attr in obj){
        // attr => "a" , "b";
        obj[attr];
    }
    obj.a 
    obj["a"];

    obj.attr   // 有attr当成变量的能力么? 
    obj["attr"]
```
解决：因为用点,代表在对象中寻找attr这个对应的key 点后面不能用变量。


###28程序讲解
```javascript
    function foo(o){
        // 1. 先声明提升  var o;
        // 2. o 形参被 实参赋值 ;
        // o ==> 实参;
        console.log(o)
        o.a++;
        var o = {a : 20} // 对象② 
        o.a ++;
    }
    var obj = {a : 10}; // obj 存的是地址; 对象①
    foo(obj);
    console.log(obj);            
```
>  声明提升优先于实参给形参赋值 ,如果同时存在声明提升和实参赋值的话,那么实参赋值有效。


###29获取输入框value值时，为什么onkeydown和onkepress获取的总是少一位，而onkeyup能够正常获取。
> 事件的执行顺序问题;

###30 现在上完课基本有三方面的事情要做，一是消化练习上课讲的内容，二是做作业，三是整理笔记，如果当天自习时间不够的话，相对来说哪个环节可以往后放一放？

> 以当天学习内容为主;
> 可以把整理笔记任务简化, 20分钟以内完成。 
> 利用周四周日时间把笔记细化整理。


**问题1  怎么封装getAttribute() 方法？**
```javascript
        function myGetAttribute(ele){
            var attrList = ele.attributes;
            var arr = []
            for(var i = 0 ;i<attrList.length;i++){
                arr[i] = attrList[i]
            }
            return arr;
        }
```

**问题2  box.createAttribute("test");和this.createAttribute(key);的差别在哪？我的理解this指向的就是box，为什么第一个方法会报错，而第二个是正常的？**
```javascript
<body>
        <div id="box0" data-id="hello">
                <span>hello world</span>
        </div>
    <script>

        var box = document.getElementById("box0");

        // var test = box.createAttribute("test");
        // test.nodeValue = "testValue1";
        // console.log(box);
        /*
        attribute.html:19 Uncaught TypeError: box.createAttribute is not a function
        at attribute.html:19
        */
        function setAttribute(key,value){
			var myAttr = this.createAttribute(key);
			myAttr.nodeValue = value;
            // var test1 = document.createAttribute(key);
		    // test1.nodeValue = value1;
		    // this.setAttributeNode(test1);
		    // console.log(box);
		}
        box.setAttribute("test1","lulizhong1");
        // box.setAttribute("test2","lulizhong2");
        console.log(box);
// 解决： 创建属性的方式是： var attr = document.createAttribute("属性名")   attr.nodeValue = "test"    
//自定义的函数的调用的方式是  setAttribute(key,"value")   
    </script>
</body>
```


**问题3 外部函数的变量timer是否被内部函数引用？外部函数被调用时，内部函数是否立即执行，是否构成了闭包？timer赋值null后，数据被清空，timer这个变量是否还在？**
   ![image.png]https://upload-images.jianshu.io/upload_images/18429017-2a03b77d346fdfd5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240
>解决：是被内部函数引用,内部函数在定时器设定的时间后执行,构成闭包,timer这个变量在赋值为null之后不久会被垃圾回收机制回收


**问题4 两种创建节点的区别**

添加属性节点
方法一:
var myAttr = document.createAttribute("data-hello");
myAttr.nodeValue = "helloWorld";
box.setAttributeNode(myAttr);
方法二:
box.setAttribute("data-hello","helloworld");
添加文本节点
方法一：
var textNode = document.createTextNode("hello world");
box.appendChild(textNode);
方法二：
box.innerHTML = "hello world"
box.innerText = "hello world" 
>解决：没有区别,只是一个是封装好的,一个是一步一步实现的


**问题5 跳转页面时，什么时候用open(),什么时候用location.href = ""；**
>解决：
* location.href   原页面改变
* open            打开新页面


**问题6 bind指向对象传false该怎么理解？是说它不固定指向吗？**
>解决：传入 false 就是不改变 this 指向。


**问题7 事件委托封装里的创建按钮函数里传不传参数e,有什么区别和影响吗？啥时候该传，啥时候不用传？**
![image.png](https://upload-images.jianshu.io/upload_images/12728563-ac3ff12e234d0226.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
>解决  当事件处理函数中需要使用事件对象的时候就需要传过去,如果不需要就可以不传


**问题8 这段代码看不太懂。**
![image.png](https://upload-images.jianshu.io/upload_images/2845301-15ce0512765d711b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
> 面向对象 ; 构造函数,原型实例。 稍后会学习。


**问题9 正则表达式中的全局修饰符g和贪婪匹配的关系，有全局修饰符，一定是贪婪吗？**
> 贪婪      是和量词有关的。  +  *  ?  
> 尽可能多的匹配符合规则的字符。   一次尽可能匹配更多;
> 修饰符 g  驱动方法多次匹配;      在整条字符串上多次进行匹配;


**问题10 提问在图中 代码如下**
![image.png](https://upload-images.jianshu.io/upload_images/12728563-ebac1f33e890622d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```javascript
			var arr = [[1,2,3,4,5],[3,4,5,6,7],5,6];
			function flat(arr){
				// if(!flat.res){
				if(arguments.length === 1){
					flat.res = [];
				}

<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		<script type="text/javascript">
			var arr = [[1,2,3,4,5],[3,4,5,6,7],5,6];
			function flat(arr){
				if(!flat.res){
					flat.res = [];
				}
				
				for(var i = 0 ; i<arr.length;i++){
					if( !(arr[i] instanceof Array) ){
						flat.res.push(arr[i]);
					}else{
						flat(arr[i] , false);
						flat(arr[i]);
					}
				}
				return flat.res;
			}	
			var arr2 = [1,2,3,4]
			console.log(flat(arr));
			console.log(flat(arr2));
```
* 递归时我们去进行区分，是外部调用 ; 还是内部递归用。 根据两种情况进行区分操作。

**问题11 智哥，问两个 VScode的快捷键。  超出可视区域的代码或者注释 是怎么自动换行的？怎么同时选中相同的函数名一起修改？**
* ALT + Z 
* CTRL + D


**问题12 智哥，replace()如何替换多个内容，比如我能在输入框里一下子输入 ：术语、正则，然后替换吗？**
* 匹配到了更多内容。 => 规则允许更多内容; 
* 把规则写好，写全那么replace 会自动帮你进行匹配的;
var reg = /术语|正则/g; 

**问题13**
![QQ截图20190629081155.png](https://upload-images.jianshu.io/upload_images/14040632-322f62a373dfaefd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
* 组 : 在正则表达式中 `()` 代表组 , 你在后面进行使用的时候 可以用 $n 去替代 , n是怎么去赋值的那 ? 从左到右第一个组为1(第一个括号之中的内容)

**问题14 在高级查找中，再次查找前如何清除清除上次查找到的高光标记？？？**
```html
<!DOCTYPE html>
<html lang="en">
<head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="X-UA-Compatible" content="ie=edge">
      <title>Document</title>
      <style>
            span{
                  background: yellowgreen;
            }
      </style>

</head>
<body>
      <input type="text" id="search"> 
      <p id="content">
                  <span>正则</span>  表达式的“鼻祖”或许可一直追溯到科学家对人类神经系统工作原理的早期研究。美国新泽西州的Warren McCulloch和出生在美国底特律的Walter Pitts这两位神经生理方面的科学家，研究出了一种用数学方式来描述神经网络的新方法，他们创造性地将神经系统中的神经元描述成了小而简单的自动控制元，从而作出了一项伟大的工作革新。
                  在1951 年,一位名叫Stephen Kleene的数学科学家，他在Warren McCulloch和Walter Pitts早期工作的基础之上，发表了一篇题目是《神经网事件的表示法》的论文，利用称之为正则集合的数学符号来描述此模型，引入了正则表达式的概念。正则表达式被作为用来描述其称之为“正则集的代数”的一种表达式，因而采用了“正则表达式”这个术语。
                  之后一段时间，人们发现可以将这一工作成果应用于其他方面。Ken Thompson就把这一成果应用于计算搜索算法的一些早期研究，Ken Thompson是 Unix的主要发明人，也就是大名鼎鼎的Unix之父。Unix之父将此符号系统引入编辑器QED，然后是Unix上的编辑器ed，并最终引入grep。Jeffrey Friedl 在其著作《Mastering Regular Expressions (2nd edition)》（中文版译作：精通正则表达式，已出到第三版）中对此作了进一步阐述讲解，如果你希望更多了解正则表达式理论和历史，推荐你看看这本书。
                  自此以后，正则表达式被广泛地应用到各种UNIX或类似于UNIX的工具中，如大家熟知的Perl。Perl的正则表达式源自于Henry Spencer编写的regex，之后已演化成了pcre（Perl兼容正则表达式Perl Compatible Regular Expressions），pcre是一个由Philip Hazel开发的、为很多现代工具所使用的库。正则表达式的第一个实用应用程序即为Unix中的 qed 编辑器。
                  然后，正则表达式在各种计算机语言或各种应用领域得到了广大的应用和发展，演变成为计算机技术森林中的一只形神美丽且声音动听的百灵鸟。
                  以上是关于正则表达式的起源和发展的历史描述，如今正则表达式在基于文本的编辑器和搜索工具中依然占据着一个非常重要的地位。
                  在最近的六十年中，正则表达式逐渐从模糊而深奥的数学概念，发展成为在计算机各类工具和软件包应用中的主要功能。不仅仅众多UNIX工具支持正则表达式，近二十年来，在WINDOWS的阵营下，正则表达式的思想和应用在大部分 Windows 开发者工具包中得到支持和嵌入应用！从正则式在Microsoft Visual Basic 6 或 Microsoft VBScript到.NET Framework中的探索和发展，WINDOWS系列产品对正则表达式的支持发展到无与伦比的高度，几乎所有 Microsoft 开发者和所有.NET语言都可以使用正则表达式。如果你是一位接触计算机语言的工作者，那么你会在主流操作系统（*nix[Linux, Unix等]、Windows、HP、BeOS等）、主流的开发语言（delphi、Scala、PHP、C#、Java、C++、Objective-c、Swift、VB、Javascript、Ruby以及Python等）、数以亿万计的各种应用软件中，都可以看到正则表达式优美的舞姿。
      </p>

      <script>
            var content = document.getElementById("content");
            var search = document.getElementById("search");
            search.addEventListener("keydown" , function(evt){
                  var e = evt || window.event;
                  var keyCode = e.keyCode || e.which;
                  if(keyCode === 13){
                        heighLight();
                  }
            })
            
            function heighLight(){
                  var value = search.value ; 
                  var contentText = content.innerHTML;
                  // console.log()
                  var nowReg = new RegExp("("+value+")","g");
                  // content.innerHTML = contentText.replace(nowReg  , "<span>"+ value +"</span>")
                  // console.log(nowReg);
                  // 在替换时得到匹配的内容(匹配的结果);
                  content.innerHTML = contentText.replace(nowReg  , "<span> $1 </span>")
            }        
      </script>
</body>
</html>
```
```javascript
      var regSpan = /<\/?span>/g
```


**问题15 为什么要在表单验证里的匿名函数传入window对象,有什么作用?我试过,不传window也行**
* 减少原型链访问的次数,优化性能; 我们只会传window , 或者jQuery 。


**问题16 这两个设置属性的语句有啥区别么?**
![img](https://upload-images.jianshu.io/upload_images/18300474-5a22c85611781f7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
>解决:li[i].index = i 设置的属性是不会在标签中显示的 而li[i].setAttribute("index",1)是在标签中设置了属性为index值为1的属性


**问题17 上面删掉之后  下面还能获取到rec.ele么?**
![img](https://upload-images.jianshu.io/upload_images/18300474-e68a66db54778fa4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
>解决：rec.ele已经获取到了数组中元素的引用,下面的操作是在数组中删除记录,但是rec.ele已经获取到了引用,所以不会影响到


**问题18 border-radius: 5px;加上这条属性mouseup失效**
  ![](https://upload-images.jianshu.io/upload_images/18300474-d866a350fbf73e68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
>解决：因为元素的位置随着鼠标移动,元素的位置设置是将左上角挨着鼠标,.当元素的设置border-radius之后,鼠标的位置没有元素,所以移动会失效


**问题19 事件绑定范围太小，border-radius 设置之后事件无法触发;**
> 更改 事件触发范围为document即可;


**问题20 获取事件源，目标阶段的那个元素不用绑定事件也能获取到吗？**
   ![image.png](https://upload-images.jianshu.io/upload_images/18300474-492c7dbdada04613.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
>所有document或者window接受到的事件都是冒泡|捕获来的;


**问题21 为什么类型判断的时候不能用Number判断呢?**
```javascript
    function myFlat(arr) {
    if (!myFlat.newArr) {
        myFlat.newArr = [];
    }
    for (var i = 0; i < arr.length; i++) {
        // if(new Number(arr[i]) instanceof Number);//为啥不能用Number判断？
        // typeof => 基本类型;
        if (!(arr[i] instanceof Array)) {
            myFlat.newArr.push(arr[i]);
        } else {
            myFlat(arr[i]);
        }
    }
    return myFlat.newArr;
    }
```
> instance => 实例;
> of        
> 实例 : new Number(); => 构造函数构造出来的对象。
> 基本类型和构造函数构造出来的类型。
> 基本类型 : 是一个纯数据;  不存在太多高级引用关系。
> 构造出来的基本类型 : 因为是一个对象，所以具备所有js对象的特征，比较复杂。


**问题22 如下图,给密码设置完密码强度之后,当需要判断密码强度时,起始的密码正则(策略列表里的password)长度就会失效**
![image.png](https://upload-images.jianshu.io/upload_images/18300474-c2da4bf5fd8e6423.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
* 优化逻辑判定文字符合规则之后终止程序。


**问题23 输出的是什么意思？为什么上面是length是2，下面显示是**
![img.png](https://upload-images.jianshu.io/upload_images/18306946-7d6c11dbc011b138.png?imageMogr2/auto-orient/)

> 输出的是  box元素的所有属性节点。 以列表的形式存在(伪数组) ;  
> 后面的代码没有注意到 ，要注意看整体代码呦 !  js没有灵异现象呦!


**问题24 DOM 、Document、Bom 、Location接口和Window对象中的location 的关系是啥？Location,Document接口、Window对象、元素和DOM 元素和Document他们之间到底是什么关系呐？就是这一大串，关系傻傻分不清楚。。。是JS 中Window 是实现他们的载体吗？还是什么？ 还有那个元素的类型根元素是HTMLElement,他们分别又是一种类型，那些属性，ID 好像又不一样是继承谁的啊？ 搞不懂 在打印属性节点的时候 上面显示所有属性，但是详情就没有，是为啥？**

![DOM结构](https://upload-images.jianshu.io/upload_images/16960494-55ba94ac99f843b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


**问题25**
```javascript
    function createElement(type, attr, value) {
    var ele = document.createElement(type);
    ele[attr] = value;
    ele.innerHTML = "hello world";
    return ele;
}
console.log(createElement("p", "innerHTML", "hello world"));
// 为什么打印的结果为<p>hello world</p>而不是<p innerHTML="hello world"></p>？？
// ele.innerHTML是节点属性 , ele[attr]对象属性;
```


**问题26**
```javascript
    var li = createElement({
        type: "li",
        children: [{
                type: "input",
                attr: {
                    type: "checkbox"
                }
            },
            {
                type: "p",
                html: iptValue
            },
            {
                type: "a",
                html: "-"
            }
        ]
    })
    for (var i = 0, childEle; domJson.children && (childEle = domJson.children[i++]);) {
    childEle.nodeType === 1 ? ele.appendChild(childEle) : ele.appendChild(createElement(childEle));
    // 这句话还是不太懂，此时的childEle不应该只是三个对象{type: "p",html: iptValue}吗？怎么判断一个对象的nodeType值？
    // 为什么判定nodeType值 ?   判定是不是元素节点; 
    //解决：如果是元素  那么ele就直接appendChild,如果是对象,那么就递归再进行一次处理再append,nodeType是1就是元素节点
    }
```


**问题27 bind怎么使用**
>解决
```javascript
      // 1. 具名函数bind用法 :
      function foo(){}
      var newFoo = foo.bind();
      // 2. 匿名函数bind用法
      var foo = function(){

      }.bind()
```


**问题28 拖拽里面的柯里化再讲一遍。**
* bind封装的柯里化;
* 函数嵌套，函数调用函数。
```javascript
      function myBind( fn , _this ){
            return function(){
                  fn.call(_this)
            }
      }
```


**问题29 为什么移动回放的时候 没有回到原来的位置？**
https://github.com/embaobao/webstudy/tree/master/2019.6.24._2.js.EventBubble/work-favoriteMuse
* 第一次记录位置时，元素位置已经发生改变。因为记录的地点在move事件之中。


**问题30 offsetLeft , offsetTop,   事件对象 e.clientX; e.clintY, e.offsetX,e.offsetY, e.screenX,e.pageY;区别**
* offsetLeft , offsetTop 获取元素距离可视区域的left值和top值; 是否有存在position属性的父级;
* client 可视区到鼠标点的x轴距离。
* offset 事件源到鼠标点的x轴距离。
* screen 屏幕到鼠标点x轴距离。
* page   文档到鼠标点x轴距离。


**问题31 事件委托封装时候 在执行循环之前判断点击了父元素，是否会有优化？**
   ![img.png](https://upload-images.jianshu.io/upload_images/15342731-18eb18d581aadfa8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
* 减少循环执行次数性能一定优化，优化逻辑提前去根据需求定制。


**问题32 Object ,新方法 设置的时候，如果属性多的话，难到要一个个设置吗？ 有没有简写什么的？**
```javascript
      Object.defineProperties( {
            "a":{
                  get : function(){},
                  set : function(){}
            },
            "b":{

            }
      } )
```


**问题33 计时器如果作为独立的异步方法 ，那他是怎么访问到函数中的局部变量的？过程不太清楚**
```javascript
      function foo(){
            var a = 10;
            setInterval(function(){
                  console.log(a);
            },20)
      }
      var a = 10;
      setInterval(function(){
            console.log(a);
      },20)
```


**问题34 Object ,中的this 指向，说过后，还是不太清楚。**
* this指向当前属性所属的obj;


**问题35 todolist事件委托的事件类型为change，这样input里面内容不变时，就不能触发函数了，怎么解决**
* 给 input 绑定独立的事件;
```javascript
    todolist高级封装里面的这段代码看不懂
     // 判定是否存在子集;
     // 利用短路运算节省性能 , 如果没有传递 domJson.children 属性，那么我们直接跳出for循环不进行其他判断操作;
     // domJson.children && (childNode = domJson.children[i++]);
      for(var i = 0 , childNode ; domJson.children && (childNode = domJson.children[i++]);){
            // childNode => 子节点;
            // 函数的使用者定义的参数; 
            // 1. 元素节点; => 直接插入父级
            // 2. 结构对象; => 创建成元素 再插入父级;
            childNode.nodeType === 1 ? ele.appendChild(childNode) : ele.appendChild( createElement(childNode) )
      }
      return ele ;
}
```


**问题36 toString为什么能实现数组只有字符串的扁平化.**
> 扁平化的骚操作;
> var arr = [1,[2,3,4,5],6];
> arr.toString().split(",");

* 因为数组在调用 toString 的过程中,会忽略数组的结构,把所有的数据以 `,` 为间隔拼接成一个字符串;


**问题37 浅拷贝和深拷贝的区别.**
* 对象的深浅拷贝。
* 深拷贝 引用传递|克隆地址
	    var cloneObj = obj
		引用传递  obj和cloneObj指向同一个地址，一模一样  obj===cloneObj
* 浅拷贝
    创建全新的引用类型，根据源类型进行赋值
	简单的深克隆
		var cloneObj = {}
        for(var attr in obj){
            cloneObj[attr]  = obj[attr]
        }
	对象合并方式
		var  cloneObj = Object.assign({} , obj)
	JSON的方式
		var cloneObj = JSON.parse(JSON.stringify(obj))


**问题38 表单验证事件处理函数为什么要用bind.**
* 因为要传递参数 


**问题39 正则表达式什么时候用小括号，什么时候用中括号？**
* () 组;       => 需要获取到匹配字符;
* [] 元字符;   => 匹配多个或的时候使用元字符; 


**问题40 直接让handlerMoving这个函数this指向存储坐标的obj，不用传参也可以直接通过this来获取offsetX，Y，这样做可以吗 ？为什么要避免this指向数据？**
   ![图片1](https://www.xyhthink.com/img/1.png)
   ![图片2](https://www.xyhthink.com/img/2.png)
- 以后编程会用到实例;
- 一般情况下函数内的this => 1. 不用 ; 2. this指向实例。


**问题41 柯里化和闭包有什么区别和联系？**
- 柯里化为什么存在 ？ 创建时改变函数特征(参数,this指向);
- 闭包            ？ 1. 延长变量声明周期 2. 保密
- 区别 : 在于最终目的和编程导向。
- 联系 : 柯里化使用闭包机制。


**问题42 柯里化和闭包有什么区别和联系？**
- 柯里化为什么存在 ？ 创建时改变函数特征(参数,this指向);
- 闭包            ？ 1. 延长变量声明周期 2. 保密
- 区别 : 在于最终目的和编程导向。
- 联系 : 柯里化使用闭包机制。


**问题43 可以将代码中的this.outHTML改为this.outerText**
```javascript
   // 点个赞! 
   function handlerWriteText(){
       //this.outerHTML = this.value;
      this.outerText = this.value;
   }
   //可以防止修改内容时 将输入的<>里面的内容转化为HTML元素或者可执行的代码，导致再次点击无法修改或者页面崩溃的BUG。
```


**问题44**
   ```javascript
       function Foo() {
           getName = function () {
               console.log(1);
           };
           return this;
       }
       Foo.getName = function () {
           console.log(2);
       };
       Foo.prototype.getName = function () {
           console.log(3);
       };
       var getName = function () {
           console.log(4);
       };
       function getName() {
           console.log(5);
       }
   
       Foo.getName();                      
       getName();                          
       Foo().getName();                    
       getName();                          
       new Foo.getName();                  
       new Foo().getName();                
       new new Foo().getName();    
   ```
- 后面再说


**问题45**
![Q1](https://www.xyhthink.com/img/0628.png)
   为什么倒数第二行obj1里面c是3
> assign 第一层为深复制，后面为浅复制。


1.for循环可以遍历对象吗？
>不可以;

2.用 for in 遍历对象时为什么用中括号取值而不用点取属性值。取属性值时哪种情况用点，哪种情况用中括号。
>点只能是指定属性，中括号可以用变量，更灵活。

3.函数如果传入参数以 0123 数字形式传入函数 函数的参数会以8进制显示，有没有解决方案，让他传入的参数变为10进制.
>无法解决，逆规则

4.获取输入框value值时，为什么onkeydown和onkepress获取的总是少一位，而onkeyup能够正常获取。
> 事件的执行顺序问题;onkeydown和onkeypress会在字符输入之前触发，onkeyup会在字符输入之后触发。
    
5.讲一下考试的选择题。
> 稍后讲;

6.讲一下QQ延时提示框。
> 案例见;

7.现在上完课基本有三方面的事情要做，一是消化练习上课讲的内容，二是做作业，三是整理笔记，如果当天自习时间不够的话，相对来说哪个环节可以往后放一放？

> 以当天学习内容为主;
> 可以把整理笔记任务简化, 20分钟以内完成。 
> 利用周四周日时间把笔记细化整理。

```javascript
    function foo(){
                  // arguments.indexOf(1);
                  // var arg = mySlice(arguments);
                  // console.log(arg.indexOf(1));
                  // 1. 记住他;
                  console.log([].slice.call(arguments));
                  // 2. 
                  console.log(slice().call(arguments));  (这两种方法有什么区别吗？)
            }           
            // 反柯里化;
            function slice(){
                  // console.log(Array.prototype.slice)
                  return Array.prototype.slice;
            }                                          (这种方法看不懂)  
```

```javascript
    var obj = { a : 10 , b : 20}
    for(var attr in obj){
        // attr => "a" , "b";
        obj[attr];
    }
    obj.a 
    obj["a"];

    obj.attr   // 有attr当成变量的能力么? 
    obj["attr"]
```


```javascript
    function foo(o){
        // 1. 先声明提升  var o;
        // 2. o 形参被 实参赋值 ;
        // o ==> 实参;
        console.log(o)
        o.a++;
        var o = {a : 20} // 对象②
        o.a ++;
    }
    var obj = {a : 10}; // obj 存的是地址; 对象①
    foo(obj);
    console.log(obj);            这个不太懂
```

>  声明提升优先于实参给形参赋值 ,如果同时存在声明提升和实参赋值的话,那么实参赋值有效。

1.bind怎么使用。

```javascript
      // 1. 具名函数bind用法 :

      function foo(){}

      var newFoo = foo.bind();

      // 2. 匿名函数bind用法

      var foo = function(){

      }.bind()

```

2.拖拽里面的柯里化再讲一遍。

* bind封装的柯里化;
* 函数嵌套，函数调用函数。
```javascript
      function myBind( fn , _this ){
            return function(){
                  fn.call(_this)
            }
      }
```

3.https://github.com/embaobao/webstudy/tree/master/2019.6.24._2.js.EventBubble/work-favoriteMuse
为什么移动回放的时候 没有回到原来的位置？

* 第一次记录位置时，元素位置已经发生改变。因为记录的地点在move事件之中。

4.toString为什么能实现数组只有字符串的扁平化.
> 扁平化的骚操作;
> var arr = [1,[2,3,4,5],6];
> arr.toString().split(",");

* 因为数组在调用 toString 的过程中,会忽略数组的结构,把所有的数据以 `,` 为间隔拼接成一个字符串;

5.表单验证事件处理函数为什么要用bind.

* 因为要传递参数 

6.正则表达式什么时候用小括号，什么时候用中括号？

* () 组;       => 需要获取到匹配字符;
* [] 元字符;   => 匹配多个或的时候使用元字符; 

7.浅拷贝和深拷贝的区别.

* 见问题汇总文件夹下0628文件夹；

8. offsetLeft , offsetTop,   事件对象 e.clientX; e.clintY, e.offsetX,e.offsetY, e.screenX,e.pageY;
   
* offsetLeft , offsetTop 获取元素距离可视区域的left值和top值; 是否有存在position属性的父级;
* client 可视区到鼠标点的x轴距离。
* offset 事件源到鼠标点的x轴距离。
* screen 屏幕到鼠标点x轴距离。
* page   文档到鼠标点x轴距离。

9. 事件委托封装时候 在执行循环之前判断点击了父元素，是否会有优化？
   ![img.png](https://upload-images.jianshu.io/upload_images/15342731-18eb18d581aadfa8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* 减少循环执行次数性能一定优化，优化逻辑提前去根据需求定制。

10.  Object ,新方法 设置的时候，如果属性多的话，难到要一个个设置吗？ 有没有简写什么的？

```javascript
      Object.defineProperties( {
            "a":{
                  get : function(){},
                  set : function(){}
            },
            "b":{

            }
      } )
```

11.  计时器如果作为独立的异步方法 ，那他是怎么访问到函数中的局部变量的？过程不太清楚

```javascript
      function foo(){
            var a = 10;
            setInterval(function(){
                  console.log(a);
            },20)
      }

      var a = 10;
      setInterval(function(){
            console.log(a);
      },20)
```
12.  Object ,中的this 指向，说过后，还是不太清楚。

* this指向当前属性所属的obj;

13.  todolist事件委托的事件类型为change，这样input里面内容不变时，就不能触发函数了，怎么解决

* 给 input 绑定独立的事件;

```javascript
    todolist高级封装里面的这段代码看不懂
     // 判定是否存在子集;
     // 利用短路运算节省性能 , 如果没有传递 domJson.children 属性，那么我们直接跳出for循环不进行其他判断操作;
     // domJson.children && (childNode = domJson.children[i++]);
      for(var i = 0 , childNode ; domJson.children && (childNode = domJson.children[i++]);){
            // childNode => 子节点;
            // 函数的使用者定义的参数; 
            // 1. 元素节点; => 直接插入父级
            // 2. 结构对象; => 创建成元素 再插入父级;
            childNode.nodeType === 1 ? ele.appendChild(childNode) : ele.appendChild( createElement(childNode) )
      }
      return ele ;
}
```


### 问题 1：这两个设置属性的语句有啥区别么?![](https://upload-images.jianshu.io/upload_images/18300474-5a22c85611781f7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

> 一个可以在属性中看到，一个看不到

### 问题 2：getAttribute() 的封装不会写

```javascript
function myGetAttribute(ele) {
  var attrList = ele.attributes;
  var arr = [];
  for (var i = 0; i < attrList.length; i++) {
    arr[i] = attrList[i];
  }
  return arr;
}
```

### 问题 3：上面删掉之后 下面还能获取到 rec.ele 么?![](https://upload-images.jianshu.io/upload_images/18300474-e68a66db54778fa4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

> 上面删掉的是数组里的数据，并没有影响到下面

### 这两种方法有什么区别嘛？

> 解决：没有区别,只是一个是封装好的,一个是一步一步实现的

### 问题 4:border-radius: 5px;加上这条属性 mouseup 失效

![](https://upload-images.jianshu.io/upload_images/18300474-d866a350fbf73e68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

- 事件绑定范围太小，border-radius 设置之后事件无法触发;
  > 更改 事件触发范围为 document 即可;

### 问题 5:获取事件源，目标阶段的那个元素不用绑定事件也能获取到吗？

![image.png](https://upload-images.jianshu.io/upload_images/18300474-492c7dbdada04613.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
> 能，因为当次事件是一个流，所有document或者window接受到的事件都是冒泡|捕获来的;

### 问题 6: 为什么类型判断的时候不能用Number判断呢?
```javascript
    function myFlat(arr) {
    if (!myFlat.newArr) {
        myFlat.newArr = [];
    }
    for (var i = 0; i < arr.length; i++) {
        // if(new Number(arr[i]) instanceof Number);//为啥不能用Number判断？
        // typeof => 基本类型;
        if (!(arr[i] instanceof Array)) {
            myFlat.newArr.push(arr[i]);
        } else {
            myFlat(arr[i]);
        }
    }
    return myFlat.newArr;
    }
```
> instance => 实例;
> of        
> 实例 : new Number(); => 构造函数构造出来的对象。
> 基本类型和构造函数构造出来的类型。
> 基本类型 : 是一个纯数据;  不存在太多高级引用关系。
> 构造出来的基本类型 : 因为是一个对象，所以具备所有js对象的特征，比较复杂。

### 问题 7:如下图,给密码设置完密码强度之后,当需要判断密码强度时,起始的密码正则(策略列表里的password)长度就会失效
![image.png](https://upload-images.jianshu.io/upload_images/18300474-c2da4bf5fd8e6423.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* 优化逻辑判定文字符合规则之后终止程序。

### 问题 8:如下图,即使strengt="false"(用户是否需要密码强度验证),仍然会进入密码强度验证函数
![image.png](https://upload-images.jianshu.io/upload_images/18300474-8131544740c43682.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* 更新一哈，上图描述正确。

### 问题 9:那个重力回弹运动，为什么他的速度和高度每一次都会减小？
* 每次速度到达不了上次的值，会有损耗。

### 问题 10:在烟花中调用move方法时候，把判断条件改成为{ }空对象，无法执行
![image.png](https://upload-images.jianshu.io/upload_images/18300474-41eb5ac96adaefa0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
* 判定对象为空的逻辑;  
* 1. for in 判定;
* 2. Object.keys() 判定;
* {} == "{}" 左边的值会toString()  => "[Object object]"

### 问题 11:智哥,昨天的烟花能再捋一遍吗？

* 捋过了;

### 问题 12:图片里for循环判断 改成红框里写的方式,可以稍微优化代码。

![QQ图片20190702182508.png](https://upload-images.jianshu.io/upload_images/18300474-5e326077c9a2080e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* 会更好看一些，但是性能没有提升。

### 问题 13: 事件委托后，获取事件下标的方法有几种，烦请智哥讲解一下

```javascript
      // 找父级, 父级之中找子集。

      // this => 委托的元素;
      var res = 0;
      Array.from(this.parentNode.children).forEach(function( ele , index){
            if(this === ele){
                  res = index;
            }
      }.bind(this))

      // 给每一个元素直接标记;
      Array.from(this.parentNode.children).forEach( function(ele, index){     
            ele.index = index;
      })
      // ele => ele.index ;

      // 闭包;
      // 在封装委托的底层进行处理;
```


###问题1  box.createAttribute("test");和this.createAttribute(key);的差别在哪？我的理解this指向的就是box，为什么第一个方法会报错，而第二个是正常的？

```javascript
<body>
        <div id="box0" data-id="hello">
                <span>hello world</span>
               
                <!-- i'm comment  -->
        </div>
    <script>

        var box = document.getElementById("box0");

        // var test = box.createAttribute("test");
        // test.nodeValue = "testValue1";
        // console.log(box);
        /*
        attribute.html:19 Uncaught TypeError: box.createAttribute is not a function
        at attribute.html:19
        */

        function setAttribute(key,value){
			var myAttr = this.createAttribute(key);
			myAttr.nodeValue = value;


            // var test1 = document.createAttribute(key);
		    // test1.nodeValue = value1;
		    // this.setAttributeNode(test1);
		    // console.log(box);
		}
        box.setAttribute("test1","lulizhong1");
        // box.setAttribute("test2","lulizhong2");
        console.log(box);

     
    </script>
</body>

```

思路：自定义方法和系统方法同名，后面调用的是系统方法，而不是自己定义的方法。  第二个正常是错觉。
createAttribute方法使用是固定为：document.createAttribute("key");
只可以修改括号内的key值


###问题2 外部函数的变量timer是否被内部函数引用？外部函数被调用时，内部函数是否立即执行，是否构成了闭包？timer赋值null后，数据被清空，timer这个变量是否还在？
   ![image.png]https://upload-images.jianshu.io/upload_images/18429017-2a03b77d346fdfd5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240
>垃圾回收机制,
>函数内声明变量时添加回收标志，
>被引用时清空回收标志，
>置空时添加回收标志

解题思路：该定时器置空时会在之后被自动回收，但是在move方法中，会继续创建下一个定时器，一直创建再清空。



###问题3 两种创建节点的区别

添加属性节点
方法一:
var myAttr = document.createAttribute("data-hello");
myAttr.nodeValue = "helloWorld";
box.setAttributeNode(myAttr);
方法二:
box.setAttribute("data-hello","helloworld");

添加文本节点
方法一：
var textNode = document.createTextNode("hello world");
box.appendChild(textNode);
方法二：
box.innerHTML = "hello world"
box.innerText = "hello world" 

>思路：实现效果相同，只是实现方法不同，一种是调用系统封装方法，一种是自己封装的方法。自己封装的方法，可能比系统方法更优秀，可能性能会稍微好一点，到效果有限。在追求极限性能时，可以自己封装，平时用系统方法就行。自己封装方法，只是为了方便理解学习。


### 问题4:跳转页面时，什么时候用open(),什么时候用location.href = ""；
* location.href   原页面改变
* open            打开新页面;
>根据需求定


### 问题5:  bind指向对象传false该怎么理解？是说它不固定指向吗？
* 传入 false 就是不改变 this 指向。固定指向false，不能再指向事件源


### 问题6: 事件委托封装里的创建按钮函数里传不传参数e,有什么区别和影响吗？啥时候该传，啥时候不用传？

![image.png](https://upload-images.jianshu.io/upload_images/12728563-ac3ff12e234d0226.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

>思路：需要使用事件对象时传入，不需要使用事件对象即可不传入


### 问题7: 正则表达式中的全局修饰符g和贪婪匹配的关系，有全局修饰符，一定是贪婪吗？  
>思路：两者是不同的，没有必然关系，贪婪存在于单次匹配中，g决定匹配次数。
> 贪婪      是和量词有关的。  +  *  ?  
> 尽可能多的匹配符合规则的字符。   一次尽可能匹配更多;
> 修饰符 g  驱动方法多次匹配;      在整条字符串上多次进行匹配;


### 问题8： 提问在图中 代码如下

![image.png](https://upload-images.jianshu.io/upload_images/12728563-ebac1f33e890622d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```javascript
			var arr = [[1,2,3,4,5],[3,4,5,6,7],5,6];
			function flat(arr){
				// if(!flat.res){
				if(arguments.length === 1){
					flat.res = [];
				}

<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		<script type="text/javascript">
			var arr = [[1,2,3,4,5],[3,4,5,6,7],5,6];
			function flat(arr){
				if(!flat.res){
					flat.res = [];
				}
				
				for(var i = 0 ; i<arr.length;i++){
					if( !(arr[i] instanceof Array) ){
						flat.res.push(arr[i]);
					}else{
						flat(arr[i] , false);
						flat(arr[i]);
					}
				}
				return flat.res;
			}	
			var arr2 = [1,2,3,4]
			console.log(flat(arr));
			console.log(flat(arr2));
```

* 递归时我们去进行区分，是外部调用 ; 还是内部递归用。 根据两种情况进行区分操作。
  
		</script>


### 问题9: 智哥，问两个 VScode的快捷键。  超出可视区域的代码或者注释 是怎么自动换行的？  怎么同时选中相同的函数名一起修改？
>解决思路：百度
* ALT + Z 
* CTRL + D


### 问题10  智哥，replace()如何替换多个内容，比如我能在输入框里一下子输入 ：术语、正则，然后替换吗？

* 匹配到了更多内容。 => 规则允许更多内容; 
* 把规则写好，写全那么replace 会自动帮你进行匹配的;

var reg = /术语|正则/g; 

![QQ截图20190629081155.png](https://upload-im
ages.jianshu.io/upload_images/14040632-322f62a373dfaefd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* 组 : 在正则表达式中 `()` 代表组 , 你在后面进行使用的时候 可以用 $n 去替代 , n是怎么去赋值的那 ? 从左到右第一个组为1(第一个括号之中的内容)


### 问题11 在高级查找中，再次查找前如何清除清除上次查找到的高光标记？？？

>思路：清除标签
```javascript

      var regSpan = /<\/?span>/g;
      content.innerHTML = contentText.replace(nowReg  , "");

```

###问题 12 为什么要在表单验证里的匿名函数传入window对象,有什么作用? 我试过,不传window也行.

>目的
* 减少原型链访问的次数,优化性能; 我们只会传window , 或者jQuery 。

>1.全局变量，可以直接在函数内部获取 
>2.如果不考虑方便性，所有形参都可以省略，直接从arguments里面获取.
>3.如果只传形参window，不传实参会报错，往undefined里面传方法报错。



###问题 1 给重力回弹小球添如下居中代码，
left: 50%;
margin-left: -20px; 
再使用 ball.style.left = ball.offsetLeft + speedX + "px";  
为什么设置偏移量时，会有20px速度的偏差，相当speedX加了个往左20px的速度。
margin-left属性和 offsetLeft属性有冲突吗？

>解决思路：获取offset值时，获取方式是先从界面中拿出目标元素，测量完再放回去。当margin-left为-20时，offset测量时多了往左的20px，，所以每次赋值时都多了20，相当往左的速度加了20px。


###问题2：下面代码，按键控制盒子移动，为什么键盘持续按下的时候会先走30px，然后停顿0.5s后连贯移动，怎么回事？
>解决思路：持续按下0.5s后才算长按，是受系统本身机制影响，键盘按下0.5s后才算长按，由系统机制决定，无法修改。


###问题3： 小球速度损耗的问题,每次小球下降到底部时,速度会少加一次g,因此理论上速度损耗为g的值,但是当把g设置成带小数的值的时候,速度损耗有时看起来没有规律,是浏览器识别的最小单位为1的缘故吗?请智哥分析一波
![重力小球.png](https://upload-images.jianshu.io/upload_images/18487325-a378dede0f4f21f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
>思路 
>重力加速运动流程：
1.速度加速度g恒定
2.当距离目标间距小于速度时，判定为到达底部，将其定在底部
3.到达底部时，速度取反，继续向上减速运动，到达顶点速度为0，受加速度影响，重复向下运动流程。
4.当速度大于于负加速度（-g）时，运动结束

保证每次弹上去的距离小于前一次距离的操作是步骤2，每次定在底部时最多减少了最大下落速度的距离。
保证停止的条件是，速度大于负加速度，落下时速度增加到最大，取反，速度大于-g则最接近停止。


### 问题4: 烟花程序中，Firework.prototype.fireworkBoom函数里的下段代码里的false不太理解，请智哥再讲解一下缘由。
![QQ截图20190702075026.png](https://upload-images.jianshu.io/upload_images/2845301-f40f51658e80023b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* bind(this,arg1)  => 生成一个新函数 => 包含了 fire_boom 元素的引用;
* 因此可以在运动结束后让元素进行删除。


###问题5  原型链的调用顺序没弄明白，请指教。

* 构造函数  
* 原型对象
* 实例对象

- 构造函数 和 原型对象之间的关系   伴生
  
  ```javascript
    function Foo(){}
    // 当一个函数出现的时候，JS会默认给他搭配一个原型对象;
    Foo.prototype
  ```

- 构造函数 和 实例对象之间的关系   创造  
  ```javascript 
    var instance  = new Foo();
    //   实例           构造函数;
  ```

- 原型对象和实例      指向
  ```javascript
    Foo.prototype => 用来储存数据,储存方法的地方

    var instace = new Foo();

    instance => {
        constructor : Foo ,         // 构造函数指针;
        __proto__   : Foo.prototype // 构造函数原型指针;
    }
  ```

* 最终目标 : 一套方法 可以重复使用,不需要多次声明。

* => 所有的方法都放在原型之中 ; 
*    实例就可以共享所有的方法了; 
*    有一个大的类别 : String | Array | Object | Number | Function | .....
*    [].forEach() 
*    所有的对象都有原型指针 => 因为所有的对象都来自构造函数;

* 面向对象编程 
* 需要一个对象 , {} × new Foo() √;
* Foo{} => 自定义实例对象 ;
```javascript
{
    constructor : Foo,
    __proto__ : Foo.prototype
}
Foo{}.a 

// 1. 在 实例对象 Foo{} 里面查看是否存在 a 属性 , 如果存在返回结果 ,如果不存在沿着 __proto__ 去进行找寻。
// 2. Foo.prototype 里面查看是否存在 a 的属性, 同上
// 3. Object.prototype 里面查看是否存放  a 的属性。

```

###问题6  new*创造*新对象,赋值给table1 , table1为实例 , 怎么理解构造函数中的this指向实例 table1 , table1不是存的是地址!;

```javascript
    // 创建实例table1
    // 可以理解为 table1调用new Table();方法吗？
    var table1 = new Table("btn-list", "content-list");

    // 1.  构造函数创建实例;

    // 如何得到实例  : 
    // ① 构造函数的返回值;
    // ② 构造函数中的this;
```


###问题7 实例调用原型的init属性方法的流程是什么样的？原型是构造函数的原型，还是实例的原型？
* 实例 | this => 访问init => 实例中没有 => 沿着原型链向上找寻 => 找到原型上的init => 得到访问结果;



###问题8  如下注释的理解正确吗？ 请大家帮忙找出理解错误的地方。
```javascript
// 构造函数创建
        function Table(btnSe, contSe){
            // this是指向实例对象，使用Table构造的对象，即 Table{} ,
            // 给实例对象添加btns属性，存放所有目标元素
            this.btns = document.getElementById(btnSe).children;
            this.conts = document.getElementById(contSe).children;
        }
        // 原型添加方法属性, 初始化init, 实例调用初始化方法
        // table1.init(); table1调用了init方法，所以init方法里面this指向实例table1 √;
        Table.prototype.init = function(){
            // 从实例对象中获取目标元素添加绑定事件，并让this指向实例对象
            for(var i=0,btn; btn= this.btns[i];i++){

                // btn.addEventListener("click",this.handlerContent);
                // 面向对象编程中所有的函数内部this指向都指向实例对象 √;

                btn.addEventListener("click",this.handlerContent.bind(this,i));
                // 实例对象中的目标元素，调用原型的属性方法，并使用bind方法将指向btn的指针this指向实例

                btn.addEventListener("click",this.changeColor.bind(this,i));
            }
        }
        // 给原型对象添加事件处理方法属性，在绑定事件时固定了this指向，所以下方法中this指向实例table1
        Table.prototype.handlerContent = function(index,evt){
            var e = evt ||window.event;
            var target = e.target ||e.srcElement;
            for(var i=0,cont; cont = this.conts[i++];){
                cont.className = "";
            }
            this.conts[index].className = "active";

        }

        Table.prototype.changeColor = function(index,evt){
            var btn = this.btns[index];
            btn.style.backgroundColor = "#"+Math.round(parseInt("ffffff",16)*Math.random()).toString(16).padStart(6,"0");
      
        }

        //构 建函数方法使用
        // 创建实例table1

        //可以理解为 table1 调用new Table();方法吗？ × 
        // 你调用的 Table 不是table1;
        var table1 = new Table("btn-list", "content-list");
        table1.init();
```
>思路 记住构造函数，原型和实例的关系，明白原型链的调用顺序。


###问题9: 轮播图从5到1后，点击页码往左滚动bug，如何修复？
>思路，可复现bug，根据情况，添加特殊情况特殊处理。
```javascript
    /**
 * 实现的目标 :
 *    1. 点击按钮翻页;
 *    2. 点击分页器翻页;
 *    3. 多种动画效果;
 *    4. 自动播放;
 *  */

 // 程序之中必须要有 ,表示当前显示图片的坐标;  nowIndex;
 // 下一页 上一页 到达某页;

 // 1. 得有元素绑定事件 ;

 // 2. options => effect : fade | slide 
 //    1. 影响基础布局;
 //    2. 影响动画效果;


 Banner.prototype.toIndex = function(index){

      // 显示为假的第一张,点击真的第一张; 
      if(this.nowIndex === this.sliders.length - 1 && index == 0){
            return false;
      }
       
      this.nowIndex = index;
      // 显示为假的第一张 ,点击其他的内容;
      if(this.nowIndex !== 0 && this.nowIndex === this.sliders.length - 1){
            this.state = "changePage";
      }else{
            this.state = "normal";
      }
      
 }
 Banner.prototype.slide = function(){
     // 动画特殊处理 => toIndex 动画; 
      if(this.state === "changePage"){
            this.wrapper.style.left = 0;
            this.wrapper.style.transition = "top 1s";
      }
      switch(this.state){
            // 增加BUG解决动画;
            case "changePage":
                  setTimeout(function(){
                        this.wrapper.style.transition = "left 1s";
                        this.wrapper.style.left = -this.nowIndex * this.main.offsetWidth + "px"
                  }.bind(this) ,0) 
                  break;
            case "normal" : 
                  this.wrapper.style.left = 0;
                  this.wrapper.style.transition = "left 1s";
                  setTimeout(function(){
                        this.wrapper.style.left = -this.nowIndex * this.main.offsetWidth + "px"
                  }.bind(this) , 0) 
                  break;
            case "changeFirst":
                  this.wrapper.style.transition = "top 1s";
                  this.wrapper.style.left = 0;
                  setTimeout(function(){
                        this.nowIndex ++;
                        this.state = "normal";
                        this.slide();
                  }.bind(this),0);
                  break;
            case "changeLast" :
                  this.wrapper.style.transition = "top 1s";
                  this.wrapper.style.left = -(this.sliders.length - 1)* this.main.offsetWidth + "px";
                  setTimeout(function(){
                        this.nowIndex --;
                        this.state = "normal";
                        this.slide();
                  }.bind(this),0)
      }

 }

```


###问题10  为什么第一次点击左侧按钮打印不出0，也就是为啥第一次进不去if判断？
![image.png](https://upload-images.jianshu.io/upload_images/2845301-d3f1b315c2fb8968.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```javascript
    后面有操作index的for循环删除掉就好了;
```


### 问题11: 第二个let声明的i不是只在块级块级作用域里有效吗? 可不可以认为是for循环里构成闭包了，内部引用了i ，所以一直都存在?
>for循环小括号作用域是后面大括号作用域的外层作用域，for里面使用let声明变量时，大括号中引用该变量，构成了闭包。
* 理解正确;
```javascript
      var a =[];
      for(var i = 0; i<10;i++){
            a[i] = function(){
                  console.log(i);
            };
      }
      a[2]();
      console.log(a);
      console.log(a[2]) ;

      var a =[];
      for(let i = 0; i<10;i++){
            a[i] = function(){
                  console.log(i);
            };
      }
      a[2]();
      console.log(a)
      console.log(a[2]) ;
```


###问题12 京东的小图标怎么获取？
可以在 Iconfont-阿里巴巴矢量图标库 官网 下载使用图标。
* iconfont
* 

### 问题13: class的默认参数怎么设置与使用呢？ 
>使用如下：
```javascript
constructor({small_wrapper = ".small-img"}={}）{
    this.small_wrapper = static $(small_wrapper); 
}
```


###问题1: MySQL创键数据库时，连接名是用来干嘛的？只是个单纯分组吗？
![image.png](https://upload-images.jianshu.io/upload_images/2845301-bcccfe89f42d841d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* 你可能会链接很多的数据库, 用仓库名区分链接的是哪个数据库。


###问题2： 数据库遍历while循环中的=号怎么理解？ 感觉赋值 和 判断等于都不太像。

* 赋值

- 如果说一个方法的返回值既要判断又要在后面编程之中进行使用，那么这个时候我们通常用一个小技巧来处理这样的问题;

* 基本模型
```javascript
      let a ; 
      if( a = foo() ){
            console.log(a);
      }
```

```javascript
      $sql_select = "SELECT username FROM gptest";

      if($result = mysqli_query($conn,$sql_select)){
            // 查看存在多少条数据;
            // echo mysqli_num_rows($result);

            // 拿出每一条数据;
            while($row = mysqli_fetch_assoc($result)){
                  echo json_encode($row);
            }

      }else{
            echo mysqli_error($conn);
      };
```

###问题3： 可以一次给表添加(插入)多条数据(记录)吗？如果可以的话，该怎么添加呢？

```mysql
      insert into 表 
      (字段 1 , 字段 2, 字段 3, 字段 4)
      values
      (200,'haha' , 'deng' , 'shenzhen'),
      (201,'haha2' , 'deng' , 'GD'),
      (202,'haha3' , 'deng' , 'Beijing');

```

###问题4:  php解析器位于什么地方,是和js解析器一样在浏览器里吗?还是在服务器里?

* 都不是
* PHP 是一个独立的环境。 
* 只不过 服务器碰到 .php 后缀的请求会调用 cgi 去使用php解析器解析代码;

### 问题5: ajaxpost封装，报405不允许错误的原因，没理解， 老师源码在我本地换个路径也这样，而其他请求都正常。
ajaxpost.html:41 POST http://localhost/0710/data.txt?data=1 405 (Not Allowed)


###问题6: 后台服务器可以获取前端传过去的key值吗？ 后台写的固定key值'callback'，那封装中的cb_fild是不是可以省略？

* 什么是服务器 ? http服务 ;  nginx , apache , iis , nodejs , ...
```javascript
      http://www.baidu.com/v2/search?wd=hello&p=10#aaa
      协议  
             域名 
                          query(告知服务器路径)
                                     search(GET协议携带的数据) 
                                                   hash(前端用的页面传值)
```
* 解析数据 (字段值) 语言解析器来做的。
      协议携带的数据 > GET | POST 


* 后台写的固定key值'callback'，那封装中的cb_fild是不是可以省略
      可以这么操作但是不建议, 因为你的jsonp封装是面向所有使用场景的。
```php
<?php
      $cbname = $_GET['callback'];
      $data = "hello world";
      echo "$cbname('$data')";
?>
```
```javascript
function jsonp(url,cb_fild,callback){
      var GLOBAL_CB = "foo"
      // 1.全局函数;
      window[GLOBAL_CB] = function (res){
	//声明一个任意的全局函数,去调用我们需要调用的回调函数callback,该函数运行没有任何结果，只是用来传值
            callback(res)
      }
      // 2. 发送请求; 
      var script = document.createElement("script");
      url += /\?/.test(url) ? "&" : "?";
      script.src = url + cb_fild + "=" + GLOBAL_CB;
console.log(url + cb_fild + "=" + GLOBAL_CB);
      script.onload = function(){
            this.remove();
      }
      document.body.appendChild(script);
}
```


###问题7 能否通过传入具名函数，获取到它的函数名字符串，如果可以这样的话，是不是可以省去设置全局函数调用回调函数的步骤？

* 高内聚 ， 低耦合 ;
* 严重耦合全局函数，封装的功能不独立。
  
```javascript
function trueCallback(res){
    console.log(22,res);
    console.log(arguments);
}
jsonpl("http://localhost/BaseServer/0711/jsonptruedata.php","trueCallback");

function jsonpl(url,calback){
    var script = document.createElement("script");
    url += /\?/.test(url) ? "&":"?";
    console.log(url);
    url = url + "fooname"+"="+calback;
    console.log(url);
    script.src = url;
    script.onload = function(){
        this.remove();
    }
    document.body.appendChild(script);
}
```

###问题8 promise连缀那里听得不太明白，具体是咋运用，请智哥再讲一下。
```javascript
      let promise = new Promise( (resolve , reject) => {
            setTimeout( a => {
                  console.log(1);
                  resolve();
            },1000)
      })
      // promise Promise resolver 
      let promise2 = promise.then( res => {
            return new Promise( ( resolve , reject ) => {
                  setTimeout( a => {
                        console.log(2);
                        resolve();
                  },1000)
            })
      })
      // 返回值是一个新的状态机 ;
      promise2.then( res => {

      })
```

###问题9  实际开发中，如果是和后台联调，服务器不在本机时，使用ajax请求时，如何让本地代码和后台服务器同源？ 

 * nginx 
 
### 问题10  智哥 能讲下TOKEN 与cookie 的关系，domain与path 的关系吗?

* token => 一种字符串加密和构成规范。 就是把 对象 里面的数据进行编码 。
> 证明你登陆了, 携带一些特殊的信息。

* cookie => 是一种浏览器端的本地存储技术。我们可以利用http去进行设置;
> 我们把token存在cookie之中。

* domain 域 !  http://*www.baidu.com*
* path   路径  http://www.baidu.com*/error/page/1*

### 问题11  免登陆案例中，为什么修改了utils里面的代码，但在浏览器控制台sources里面，还是之前的utils代码，重启浏览器和服务器都一样，电脑重启后代码正常，是浏览器缓存原因吗？该怎么处理？

* 就是浏览器缓存 : 外联的文件都会缓存; 
* 两次请求同一路径( js , css ) ; 
* 解决方案 : 我们让浏览器感觉不一样就行了 http://www.baidu.com/script.js?_时间戳 可以避免缓存;
* 手动清除缓存 ctrl + shift + delete 


### 问题1 下面出错的原因是什么呀？

![image.png](https://upload-images.jianshu.io/upload_images/18300474-02d8c1e332ca968e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![image.png](https://upload-images.jianshu.io/upload_images/18300474-32e4337f948c8745.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* 语法  :  varchar(255) 

### 问题2  智哥,下图if判断只是判断语法是否成立而不能判断是否删除吧,就算我的表里没有数据,仍然会提示成功

![image.png](https://upload-images.jianshu.io/upload_images/18300474-1ebc1b577c0775aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* 删除操作不报错就挺好。


### 问题3 请老师讲一下promise封装在ajax

```javascript
    function ajax(url  , data, type){
        return new Promise( function(resolve , reject){
            var xhr = null;
            if(XMLHttpRequest){
                  xhr = new XMLHttpRequest();
            }else{
                  xhr = new ActiveXObject("Mricosoft.XMLHTTP");
            }
            if(xhr === null) throw "浏览器不支持ajax";
            var dataStr = "";
            for(var attr in data){
                  dataStr += (dataStr.length > 0 ? "&" : "") + attr + "=" + data[attr];
            }
            type === "GET" ? url += (/\?/.test(url) ? "&" : "?") + dataStr : "";
            xhr.open( type ? type : "GET" , url );
            type === "POST" ? xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded"): "";
            xhr.send( type === "POST" ? dataStr : null );
            xhr.onreadystatechange = function(){
                  if(xhr.readyState === 4 && xhr.status === 200){
                        resolve(xhr.responseText);
                  }
            }
            // 设置超时;
            setTimeout(function(){
                  reject(xhr,"timeout");
            },8000)
        })
    }
    ajax()
    .then()
```

### 问题 4 劳烦智哥讲解一下这种 promise 连缀

```javascript
function next(n) {
  return new Promise(function(resolve, reject) {
    setTimeout(function() {
      resolve(n);
    }, 1000);
  });
}
next(1) // promise1;
  .then(function(res) {
    console.log(res);
    return next(2); 
  })
  // promise2 ;
  .then(function(res) {
    console.log(res);
    return next(3);
  })
  .then(function(res) {
    console.log(res);
    return next(4);
  })
  .then(function(res) {
    console.log(res);
  });
```

> promise连缀的封装
### 问题 5  问题在图中，是一个小bug。

![image.png](https://upload-images.jianshu.io/upload_images/18300474-7af4628697d4862f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```javascript
    function foo(type){
        // type = type ? type : "GET";
        type || type = "GET" ;
    }
```

### 问题 6 如下图,图片里框柱的东西导致请求发不出去
![123.png](https://upload-images.jianshu.io/upload_images/18300474-00b5055d08e9d695.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* 考虑代码问题 ;   浏览器是对协议进行了完整封装，你可以进行配置但是普遍不需要。 在遇到发送问题的时候，优先考虑代码层面再去考虑协议层面。


1.智哥，能再捋一下构造函数，原型和实例之间的关系吗？
* 捋过了,见一组;

2.烟花爆炸函数里面在for循环里面烟花移动，烟花是一个一个移动，因为for循环速度太快，所以才看上去是一起移动的吗？

* 异步 :
```javascript
  for(var i = 0 ; i < 10 ; i++){
      setInterval(function(){
            console.log(1)
      },200)
  }
```
for => 执行结束 => 异步队列之中的内容 => 200ms之后执行 => 回调函数;

同步循环执行结束之后再去执行move方法 => 所以看起来move方法是同时执行的(烟花同时运动);

3.智哥，可以再讲一遍烟花吗？

* 提出具体的点;

4.这里两个函数分别改变了this指向，为什么最终指向的是实例？
![image.png](https://upload-images.jianshu.io/upload_images/18442274-cfdbcb792366c2c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![image.png](https://upload-images.jianshu.io/upload_images/18442274-763af1f8f15ecb84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* 因为在使用bind方法时，这时候会创建一个新函数 ， 并且将传入函数的this固定。因所能操作的函数，都不再是原函数了，而是包裹着原函数的调用的匿名函数。
```javascript
      function bind(callback,_this){
            return function(){      
                  callback.call(_this);
            }  
      }
```

5.这两种方式都可以让变量有初始值，哪种更好呢？
![image.png](https://upload-images.jianshu.io/upload_images/18464133-2583b5911d7b91ff.jpg?imageMogr2/auto-orient/)

```javascript

      function foo( hello = "hello" ){
            console.log(hello)
      }

      function foo( hello = "hello" , { a = 1 , b = 2 , c = 3 } = {}){
            console.log(hello , a , b ,c, )
      }
      foo("world");

```

* 这两种默认值方式没有严格意义的好坏之分，只有使用场景的不同选择不同而已。
* 在函数内部使用变量时，这个时候两种方式没有区别。 区别在于传递实参的时候存在差别。
* 对象传参可以做到想要传递什么参数就传递什么参数，其余的参数可以不传。

6.轮播图思路
* banner

- **构造函数**统筹全局,作为整个程序的开始; 
      1. 接受参数;
      2. 初始各种dom对象，变量...,调用核心方法;.
-  初始化功能(init) 
      * 处理耦合关系。 调用各个方法;
      1. 调用;
      2. 事件;
-  初始布局
      1. layoutAnimate 
       因为布局本身分成两种，一种是position所有slide集中在一起的布局。另外一种是大长条布局。
            - this.options.effect 核心逻辑;
            1. slide => 大长条布局;
            2. fade  => 集中布局
            tip : switch 的使用是因为当前程序可以具备相当优秀的扩展性。
      2. layoutPagnination 
       创建页面分页器小按钮的功能。
            - 分页器是否存在 , 存在继续创建，不存在就停止;
            - 根据需求拼接分页器字符串,放入对应的位置;
-  控制下标 
      * this.nowIndex 
      * this.state 
            1. normal      => 正常情况;
            2. changeLast  => 从第一张切换到最后一张;
            3. changeFirst => 从最后一张切换到第一张;
            4. changePage  => 在最后一张假的第一张图片调用toIndex方法实现特殊bug解决
      1. prevIndex
            本身是一个循环变量的逻辑,因为slide动画需求,所以在prevIndex里面创建一个state属性用来记录特殊值;
            * this.state => changeLast
      2. nextIndex
            同上
      3. toIndex
            同上;
-  控制动画
      * fade      
            清空其余效果，给this.nowIndex元素增加效果;
      * slide
            this.nowIndex 
            1. changePage : 解决bug;
            2. normal     : 根据this.nowIndex 改变left值;
            3. changeFirst: 先挪过去,再动画;
            4. changeLast : 同上;
- 控制分页器按钮显示
      * handlerPaginationClick
            点击按钮的下标记录;
      * changePagination
            根据 this.nowIndex 结合 this.options.effect 判定应该如何显示;


1.智哥智哥，飞机大战游戏开始的时候，当我的飞机出来，如果不动鼠标的话他会一直在下面的中间发射子弹，能不能让飞机刚创建的时候就获取到鼠标的位置定位到鼠标上呢？

* 初始定位;
* Core里面获取鼠标坐标;
```javascript
      // 在 Core 之中 ,获取当前鼠标的位置。

       createPlane(){
            let ele = document.createElement("div");
            let cWidth = document.documentElement.clientWidth;
            ele.className = "plane";
            ele.style.cursor = "none";
            document.body.appendChild(ele);
            ele.style.left = this.boundary(Core.mousePosition.x,Core.mousePosition.y,ele).x + "px";
            Plane.x = ele.offsetLeft;
            Plane.y = ele.offsetTop;
            return ele;
       }

       boundary(x,y,ele){
            let minX =  this.mainSize.left;
            let maxX =  this.mainSize.left + this.mainSize.width - (this.eleSize ? this.eleSize.width : ele.offsetWidth)  ;
            x = x < minX ? minX : x;
            x = x > maxX ? maxX : x;

            y = y < 0 ? 0 : y;
            return {
                  x ,
                  y 
            }
       }    

```

2.飞机大战缩小窗口后，飞机的位置会跑出背景的限定范围，该怎么解决？

* resize 去改变窗口改变改变的值;

3.接口到底指什么？接口地址是什么？

* 接口其实就是返回数据的一个地址;
* 这个地址通常指向一个后端语言编写的文件;
* 接口是一个高级函数 => 传入参数 , 返回结果;

4.ajax和jsonp的区别与联系。

* AJAX => 异步 的 JavaScript 和 XML;

* 包含了 各种各样的请求;
      1. XHR 发起请求;  一个受同源策略但是浏览器原生支持的可以发送请求的对象。
      2. jsonp 利用script标签发起请求; 利用一个非官方提供的方式利用官方规则的漏洞发起请求的方式。

5.onreadystatechange事件处理函数中使用了xhr对象，那可以使用this吗？

      * 试一试 ; 
 
  ``` javascript
      this === xhr  // true;
      xhr.onreadystatechange = function(){
            this  === xhr 
      }     
  ```

6.cookie和token的关系。

* token => 一种字符串加密和构成规范。 就是把 对象 里面的数据进行编码 。
证明你登陆了, 携带一些特殊的信息。

* cookie => 是一种浏览器端的本地存储技术。我们可以利用http去进行设置;
我们把token存在cookie之中。


**问题1:**
给重力回弹小球添如下居中代码，
left: 50%;
margin-left: -20px; 
再使用 ball.style.left = ball.offsetLeft + speedX + "px";  
为什么设置偏移量时，会有20px速度的偏差，相当speedX加了个往左20px的速度。
margin-left属性和 offsetLeft属性有冲突吗？


**问题2：下面代码，按键控制盒子移动，为什么键盘持续按下的时候会先走30px，然后停顿0.5s后连贯移动，怎么回事？**
```javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        #p1 {
            width: 100px;
            height: 300px;
            position: absolute;
            top:450px;
            left: 0;
            background-image: url(./0.gif);
            transition: left .1s;
            background-color: yellowgreen;
        }
    </style>
</head>

<body>
    <div id="p1"></div>
    <div id="p2"></div>
    <script>
        var p1 = document.getElementById("p1");
        var p2 = document.getElementById("p2");
        var timer = null;
        var speed = 10;
        var speed2 = 30;
        var jumpFlag = 0;
        document.addEventListener("keydown", ctrl())
        function ctrl() {
            return function (evt) {
                var e = evt || window.event;
                var keyCode = e.keyCode;
                switch (keyCode) {
                    case 65: moveLeft(0, this); break;
                    case 68: moveLeft(1, this); break;
                    case 87: moveTop(200, this); break;
                    case 83: ; break;
                }
            }
        }
        function moveTop(target, dom) {
            clearInterval(dom.timer)
            if (!jumpFlag)
                jumpFlag = 1;
            dom.timer = setInterval(function () {
                if (p1.offsetTop - target <= speed) {
                    speed = -speed;
                } else {
                    p1.style.top = p1.offsetTop - speed + "px";
                    if (p1.offsetTop >= 450) {
                        jumpFlag = 0;
                        speed = - speed ;
                        clearInterval(dom.timer);
                    }
                }
            }, 12)
        }
        function moveLeft(bool,dom){
            if(bool)
            p1.style.left = p1.offsetLeft + speed2 + "px";
            else
            p1.style.left = p1.offsetLeft - speed2 + "px";
        }
    </script>
</body>

</html>

```


**问题4 小球速度损耗的问题,每次小球下降到底部时,速度会少加一次g,因此理论上速度损耗为g的值,但是当把g设置成带小数的值的时候,速度损耗有时看起来没有规律,是浏览器识别的最小单位为1的缘故吗?请智哥分析一波**
![重力小球.png](https://upload-images.jianshu.io/upload_images/18487325-a378dede0f4f21f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

//    1. 首先offset只获取元素的实际距离 (width | height | top | left) , 计算的时候有小数，会被忽略; 因为浏览器只识别1px;
//    2. 计算的时候尽可能对计算结果,元素赋值进行取证; 


**问题 5:那个重力回弹运动，为什么他的速度和高度每一次都会减小？**
>解决：因为他每一次的速度在快到的时候都会赋值为指定高度，会损失一部分的高度，g也会每次都减少，高度也在减少。

**问题 6轮播图下方数字按钮切换不会做。**
```javascript
//去到
Banner.prototype.toIndex = function (index) {
    //获取元素引用在数组中的索引也就是slides的下标
    this.nowIndex = index;
    console.log(this.nowIndex)
    // this.wrapper.style.left = -index*this.main.offsetWidth+"px"
    if (this.nowIndex == this.slides.length - 1) {
        this.state = "fenyeBug"
    }
}

//分页随着事件不断变化
Banner.prototype.fenyeChange = function () {
    //首先让所有的分页元素的active样式都初始化
    for (var i = 0, fenyeEle; fenyeEle = this.fenye.children[i++];) {
        removeClassName(fenyeEle, "pagination-bullet-active");
    }
    var index = this.nowIndex;
    if (this.options.effect == "slide") {
        index = this.nowIndex === this.slides.length - 1 ? 0 : this.nowIndex;
        console.log(index, this.state)
        //bug问题 因为从后往前和从前往后  都会有这个this.slides.length-1
        if (index == 0 && this.state == "firstJian") {
            index = this.slides.length - 2
        }
        if (index == 0 && this.state == "lastJia") {
            index = 1
        }
    }
    this.fenye.children[index].className += " pagination-bullet-active"
}
```

**问题 7**
 ```java
   function handlerMouseMove(evt){
       var e = evt || window.event;
       if(!moving){
           ball.style.left = e.offsetX - 20 + "px";
           ball.style.top = e.offsetY - 20 + "px";
       }
   }
   .mask{width: 100%; height: 100%; position: absolute; left: 0; top: 0; z-index: 999;}
   //解决小球跟随鼠标移动鬼畜的问题，智哥你说除了添加遮罩层之外，还有另外一种方法，然后就没有然后了...
   //请问另外一种解决方法是什么？
   ```
```javascript 
    //解决
        var box = document.getElementById('box');
        var small = document.getElementById("small-box");
        var boxOffsetLeft = box.offsetLeft;
        var boxOffsetTop = box.offsetTop;

        box.onmousemove = function(evt){
            var e = evt || window.event;
            var small_x = e.clientX - boxOffsetLeft- 50;
            var small_y = e.clientY - boxOffsetTop - 50;
            small_x = small_x < 0 ? 0 : small_x;
            small.style.left = small_x  + "px";
            small.style.top  = small_y  + "px";
        }
```

**问题 8:在烟花中调用move方法时候，把判断条件改成为{ }空对象，无法执行**
![image.png](https://upload-images.jianshu.io/upload_images/18300474-41eb5ac96adaefa0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
* 判定对象为空的逻辑;  
* 1. for in 判定;
* 2. Object.keys() 判定;
* {} == "{}" 左边的值会toString()  => "[Object object]"


**问题 9 烟花程序中，Firework.prototype.fireworkBoom函数里的下段代码里的false不太理解，请智哥再讲解一下缘由。**
![QQ截图20190702075026.png](https://upload-images.jianshu.io/upload_images/2845301-f40f51658e80023b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* bind(this,arg1)  => 生成一个新函数 => 包含了 fire_boom 元素的引用;
* 因此可以在运动结束后让元素进行删除。

**问题 10 原型链的调用顺序没弄明白，请指教。**

* 构造函数  
* 原型对象
* 实例对象

- 构造函数 和 原型对象之间的关系   伴生
  
  ```javascript
    function Foo(){}
    // 当一个函数出现的时候，JS会默认给他搭配一个原型对象;
    Foo.prototype
  ```

- 构造函数 和 实例对象之间的关系   创造  
  ```javascript 
    var instance  = new Foo();
    //   实例           构造函数;
  ```

- 原型对象和实例      指向
  ```javascript
    Foo.prototype => 用来储存数据,储存方法的地方

    var instace = new Foo();

    instance => {
        constructor : Foo ,         // 构造函数指针;
        __proto__   : Foo.prototype // 构造函数原型指针;
    }
  ```

* 最终目标 : 一套方法 可以重复使用,不需要多次声明。

* => 所有的方法都放在原型之中 ; 
*    实例就可以共享所有的方法了; 
*    有一个大的类别 : String | Array | Object | Number | Function | .....
*    [].forEach() 
*    所有的对象都有原型指针 => 因为所有的对象都来自构造函数;

* 面向对象编程 
* 需要一个对象 , {} × new Foo() √;
* Foo{} => 自定义实例对象 ;
```javascript
{
    constructor : Foo,
    __proto__ : Foo.prototype
}
Foo{}.a 

// 1. 在 实例对象 Foo{} 里面查看是否存在 a 属性 , 如果存在返回结果 ,如果不存在沿着 __proto__ 去进行找寻。
// 2. Foo.prototype 里面查看是否存在 a 的属性, 同上
// 3. Object.prototype 里面查看是否存放  a 的属性。

```

**问题 11 智哥,可否再捋一捋烟花的代码?**
* ok


**问题 12 new*创造*新对象,赋值给table1 , table1为实例 , 怎么理解构造函数中的this指向实例 table1 , table1不是存的是地址!;**

```javascript
    // 创建实例table1
    // 可以理解为 table1调用new Table();方法吗？
    var table1 = new Table("btn-list", "content-list");

    // 1.  构造函数创建实例;

    // 如何得到实例  : 
    // ① 构造函数的返回值;
    // ② 构造函数中的this;
```


**问题 13 实例调用原型的init属性方法的流程是什么样的？原型是构造函数的原型，还是实例的原型？**
* 实例 | this => 访问init => 实例中没有 => 沿着原型链向上找寻 => 找到原型上的init => 得到访问结果;

**问题 14 如下注释的理解正确吗？ 请大家帮忙找出理解错误的地方。**
```javascript
// 构造函数创建
        function Table(btnSe, contSe){
            // this是指向实例对象，使用Table构造的对象，即 Table{} ,
            // 给实例对象添加btns属性，存放所有目标元素
            this.btns = document.getElementById(btnSe).children;
            this.conts = document.getElementById(contSe).children;
        }
        // 原型添加方法属性, 初始化init, 实例调用初始化方法
        // table1.init(); table1调用了init方法，所以init方法里面this指向实例table1 √;
        Table.prototype.init = function(){
            // 从实例对象中获取目标元素添加绑定事件，并让this指向实例对象
            for(var i=0,btn; btn= this.btns[i];i++){

                // btn.addEventListener("click",this.handlerContent);
                // 面向对象编程中所有的函数内部this指向都指向实例对象 √;

                btn.addEventListener("click",this.handlerContent.bind(this,i));
                // 实例对象中的目标元素，调用原型的属性方法，并使用bind方法将指向btn的指针this指向实例

                btn.addEventListener("click",this.changeColor.bind(this,i));
            }
        }
        // 给原型对象添加事件处理方法属性，在绑定事件时固定了this指向，所以下方法中this指向实例table1
        Table.prototype.handlerContent = function(index,evt){
            var e = evt ||window.event;
            var target = e.target ||e.srcElement;
            for(var i=0,cont; cont = this.conts[i++];){
                cont.className = "";
            }
            this.conts[index].className = "active";

        }

        Table.prototype.changeColor = function(index,evt){
            var btn = this.btns[index];
            btn.style.backgroundColor = "#"+Math.round(parseInt("ffffff",16)*Math.random()).toString(16).padStart(6,"0");
        }

        //构 建函数方法使用
        // 创建实例table1

        //可以理解为 table1 调用new Table();方法吗？ × 
        // 你调用的 Table 不是table1;
        var table1 = new Table("btn-list", "content-list");
        table1.init();
```


**问题 15 烟花爆炸函数里面在for循环里面烟花移动，烟花是一个一个移动，因为for循环速度太快，所以才看上去是一起移动的吗？**
* 异步 :
```javascript
  for(var i = 0 ; i < 10 ; i++){
      setInterval(function(){
            console.log(1)
      },200)
  }
```
for => 执行结束 => 异步队列之中的内容 => 200ms之后执行 => 回调函数;

同步循环执行结束之后再去执行move方法 => 所以看起来move方法是同时执行的(烟花同时运动);


**问题 16 轮播图从5到1后，点击页码往左滚动bug，如何修复？**
```javascript
    /**
 * 实现的目标 :
 *    1. 点击按钮翻页;
 *    2. 点击分页器翻页;
 *    3. 多种动画效果;
 *    4. 自动播放;
 *  */

 // 程序之中必须要有 ,表示当前显示图片的坐标;  nowIndex;
 // 下一页 上一页 到达某页;

 // 1. 得有元素绑定事件 ;

 // 2. options => effect : fade | slide 
 //    1. 影响基础布局;
 //    2. 影响动画效果;


 Banner.prototype.toIndex = function(index){

      // 显示为假的第一张,点击真的第一张; 
      if(this.nowIndex === this.sliders.length - 1 && index == 0){
            return false;
      }
       
      this.nowIndex = index;
      // 显示为假的第一张 ,点击其他的内容;
      if(this.nowIndex !== 0 && this.nowIndex === this.sliders.length - 1){
            this.state = "changePage";
      }else{
            this.state = "normal";
      }
      
 }
 Banner.prototype.slide = function(){
     // 动画特殊处理 => toIndex 动画; 
      if(this.state === "changePage"){
            this.wrapper.style.left = 0;
            this.wrapper.style.transition = "top 1s";
      }
      switch(this.state){
            // 增加BUG解决动画;
            case "changePage":
                  setTimeout(function(){
                        this.wrapper.style.transition = "left 1s";
                        this.wrapper.style.left = -this.nowIndex * this.main.offsetWidth + "px"
                  }.bind(this) ,0) 
                  break;
            case "normal" : 
                  this.wrapper.style.left = 0;
                  this.wrapper.style.transition = "left 1s";
                  setTimeout(function(){
                        this.wrapper.style.left = -this.nowIndex * this.main.offsetWidth + "px"
                  }.bind(this) , 0) 
                  break;
            case "changeFirst":
                  this.wrapper.style.transition = "top 1s";
                  this.wrapper.style.left = 0;
                  setTimeout(function(){
                        this.nowIndex ++;
                        this.state = "normal";
                        this.slide();
                  }.bind(this),0);
                  break;
            case "changeLast" :
                  this.wrapper.style.transition = "top 1s";
                  this.wrapper.style.left = -(this.sliders.length - 1)* this.main.offsetWidth + "px";
                  setTimeout(function(){
                        this.nowIndex --;
                        this.state = "normal";
                        this.slide();
                  }.bind(this),0)
      }

 }

```


**问题 17 为什么第一次点击左侧按钮打印不出0，也就是为啥第一次进不去if判断？**
![image.png](https://upload-images.jianshu.io/upload_images/2845301-d3f1b315c2fb8968.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```javascript
    后面有操作index的for循环删除掉就好了;
```


**问题 18 智哥，能再捋一下代码吗?  能再讲一下分页器之后的吗?**

* banner

- **构造函数**统筹全局,作为整个程序的开始; 
      1. 接受参数;
      2. 初始各种dom对象，变量...,调用核心方法;.
-  初始化功能(init) 
      * 处理耦合关系。 调用各个方法;
      1. 调用;
      2. 事件;
-  初始布局
      1. layoutAnimate 
       因为布局本身分成两种，一种是position所有slide集中在一起的布局。另外一种是大长条布局。
            - this.options.effect 核心逻辑;
            1. slide => 大长条布局;
            2. fade  => 集中布局
            tip : switch 的使用是因为当前程序可以具备相当优秀的扩展性。
      2. layoutPagnination 
       创建页面分页器小按钮的功能。
            - 分页器是否存在 , 存在继续创建，不存在就停止;
            - 根据需求拼接分页器字符串,放入对应的位置;
-  控制下标 
      * this.nowIndex 
      * this.state 
            1. normal      => 正常情况;
            2. changeLast  => 从第一张切换到最后一张;
            3. changeFirst => 从最后一张切换到第一张;
            4. changePage  => 在最后一张假的第一张图片调用toIndex方法实现特殊bug解决
      1. prevIndex
            本身是一个循环变量的逻辑,因为slide动画需求,所以在prevIndex里面创建一个state属性用来记录特殊值;
            * this.state => changeLast
      2. nextIndex
            同上
      3. toIndex
            同上;
-  控制动画
      * fade      
            清空其余效果，给this.nowIndex元素增加效果;
      * slide
            this.nowIndex 
            1. changePage : 解决bug;
            2. normal     : 根据this.nowIndex 改变left值;
            3. changeFirst: 先挪过去,再动画;
            4. changeLast : 同上;
- 控制分页器按钮显示
      * handlerPaginationClick
            点击按钮的下标记录;
      * changePagination
            根据 this.nowIndex 结合 this.options.effect 判定应该如何显示;



**问题 19**

```javascript
Banner.prototype.slide = function(){
    switch(this.state){
        case "normal" :
            this.wrapper.style.left = 0; // 将wrapper的left设为0
            this.wrapper.style.transition = "left 1s"; // 添加了渐变属性
            setTimeout(function(){
                this.wrapper.style.left = -this.nowIndex * this.main.offsetWidth + "px" 
                // 如果这时候nowIndex为3时，将wrapper的left又设为了第四张图片的的位置，那么中间transition的过程不应该是由0到第四张图片的位置吗？
                // 而看到的是第三张到第四张的移动过程
            }.bind(this) , 0) 
            break;
        case "changeFirst":
            this.wrapper.style.transition = "top 1s";
            this.wrapper.style.left = 0;
            setTimeout(function(){
                this.nowIndex ++;
                this.state = "normal";
                this.slide();
            }.bind(this),0);
            break;
        case "changeLast" :
            this.wrapper.style.transition = "top 1s";
            this.wrapper.style.left = -(this.sliders.length - 1)* this.main.offsetWidth + "px";
            setTimeout(function(){
                this.nowIndex --;
                this.state = "normal";
                this.slide();
            }.bind(this),0)
    }
}
```
**略过一帧渲染** : 在代码执行的时候因为JS的解析线程是最最优先的，所以在给dom设置样式的时候 left = 0; 其实浏览器渲染进行还没有反应，JS解析进程到最后执行异步队列之中的功能。 浏览器才想起来渲染，但是这个时候js之中异步队列之中的值又重新对left进行了赋值，所以略过了一帧渲染。


**问题 20**
 ```javascript
   Banner.prototype.autoPlay = function () {
       var evt = new Event("click");    
       setInterval(function () {
           this.nextBtn.dispatchEvent(evt);
       }.bind(this), 3000)
   }
   //为什么new Event的事件无法显示自动轮播，但是可以改变nowIndex的值，如果使用下面注释的那种方法，就可以实现自动轮播？
   --------------------------------------------------------------------
   var evt = new CustomEvent("click", {
           bubbles   : true, //是否冒泡
           cancelable: true //表明该事件是否可以被取消默认行为
    })
   ```
* var evt = new Event("click");   
这样触发的事件是没有冒泡的;
其实所有动画效果都在main的事件上, 点击nextBtn的事件其实只是this.nowIndex 改变功能;

**问题 21: 第二个let声明的i不是只在块级块级作用域里有效吗? 可不可以认为是for循环里构成闭包了，内部引用了i ，所以一直都存在?**

* 理解正确;
```javascript
      var a =[];
      for(var i = 0; i<10;i++){
            a[i] = function(){
                  console.log(i);
            };
      }
      a[2]();
      console.log(a);
      console.log(a[2]) ;

      var a =[];
      for(let i = 0; i<10;i++){
            a[i] = function(){
                  console.log(i);
            };
      }
      a[2]();
      console.log(a)
      console.log(a[2]) ;
```


**问题 22 京东的小图标怎么获取？**
* iconfont


**问题 23: 事件委托后，获取事件下标的方法有几种，烦请智哥讲解一下**

```javascript
      // 找父级, 父级之中找子集。

      // this => 委托的元素;
      var res = 0;
      Array.from(this.parentNode.children).forEach(function( ele , index){
            if(this === ele){
                  res = index;
            }
      }.bind(this))

      // 给每一个元素直接标记;
      Array.from(this.parentNode.children).forEach( function(ele, index){     
            ele.index = index;
      })
      // ele => ele.index ;

      // 闭包;
      // 在封装委托的底层进行处理;
```

**24 BUG1解决**

```javascript
//BUG: 放大镜功能在边缘时移动会造成右边的big-img继续随着鼠标移动。
//原因：在给Big-img做定位时传入的参数为没有经过边缘检测(boundary)修正过得x, y
//解决：将第63行代码
var big_img_position = this.getBigPosition(x, y);
//修改为
var big_img_position = this.getBigPosition(cube_position.x,cube_position.y);
//即可
```
* 点赞;

**25 BUG2解决**

```javascript
//BUG: 移除className时，会造成前面的空格没有删除
//原因：构造正则表达式时转义字符被消除,并且空格字符应为\s(小写)
function removeClassName(dom , className){
      return dom.className = dom.className.replace(new RegExp("\S?"+className), "" );
 }
//解决：将\和?进行转义，并且修改为小s，即可
new RegExp("\S?"+className)  = >   new RegExp("\\s\?"+className)
```

* 点赞;

**问题 26**
```javascript

function Foo() {
    getName = function () {
        console.log(1);
    };
    return this;
}
Foo.getName = function () {
    console.log(2);
};
Foo.prototype.getName = function () {
    console.log(3);
};
var getName = function () {
    console.log(4);
};
function getName() {
    console.log(5);
}

Foo.getName();                      
getName();                          
Foo().getName();                    
getName();                          
new Foo.getName();                  
new Foo().getName();  //              
new new Foo().getName();   //
```


```javascript
// 声明提升;
var getName;
function getName() {
    console.log(5);
}
// 声明提升;

function Foo() {
    getName = function () {
        console.log(1);
    };
    // this ?  => Foo() => window;
    // new Foo()        => Foo{};
    return this;
}
// 引用类型 (函数) 函数上增加了一个getName方法;  Foo.getName;
Foo.getName = function () {
    console.log(2);
};
// 原型上增加了getName 方法;   new Foo().getName => 
Foo.prototype.getName = function () {
    console.log(3);
};
// 全局声明的赋值;
getName = function () {
    console.log(4);
};

Foo.getName();       // 2;                
getName();           // 4          
Foo().getName();     // 1  getName = function(){console.log(1)}    window.getName();      
getName();            // 1       
new Foo.getName();    // 2;             
new Foo().getName();  // 3;          
new new Foo().getName();   //Foo{}.getName();  3;
```

* 全局函数  ;
* 声明提升  ;
* 原型对象  ;
* 实例对象  ;
* 运算优先级;
**问题 27 这里两个函数分别改变了this指向，为什么最终指向的是实例？**
![image.png](https://upload-images.jianshu.io/upload_images/18442274-cfdbcb792366c2c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* 因为在使用bind方法时，这时候会创建一个新函数 ， 并且将传入函数的this固定。因所能操作的函数，都不再是原函数了，而是包裹着原函数的调用的匿名函数。
```javascript
      function bind(callback,_this){
            return function(){      
                  callback.call(_this);
            }  
      }
```

![image.png](https://upload-images.jianshu.io/upload_images/18442274-763af1f8f15ecb84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

**问题 28 这两种方式都可以让变量有初始值，哪种更好呢？**
![image.png](https://upload-images.jianshu.io/upload_images/18464133-2583b5911d7b91ff.jpg?imageMogr2/auto-orient/)

```javascript

      function foo( hello = "hello" ){
            console.log(hello)
      }

      function foo( hello = "hello" , { a = 1 , b = 2 , c = 3 } = {}){
            console.log(hello , a , b ,c, )
      }
      foo("world");

```
* 这两种默认值方式没有严格意义的好坏之分，只有使用场景的不同选择不同而已。
* 在函数内部使用变量时，这个时候两种方式没有区别。 区别在于传递实参的时候存在差别。
* 对象传参可以做到想要传递什么参数就传递什么参数，其余的参数可以不传。


**问题 29**
**贪婪规则** , **全局匹配修饰符**
* 贪婪 : 正则的特性之一 ,  只要符合规则 , 那么我们会尽可能多的拿到符合规则的内容。 
    +  触发贪婪的核心;
    *? 非贪婪模式

* 全局匹配 :  针对特殊方法 : 
    1. exec()  ; 如果存在修饰符 g : 在匹配一次结束后，下一次匹配在上一次结束的位置继续匹配。
    2. match (); 如果存在修饰符 g : 会多次匹配, 在得到第一次匹配之后再继续进行连续匹配并返回所有匹配结果。
    3. replace (); 如果存在修饰符 g : 会多次匹配 , 每次匹配到的结果都会进行替换操作;
   

**问题30**
 ```javascript
    str = str.replace(/\//g,"\/");
   //模板引擎中的这句话是不是多余的呀？  '/'不是转义字符
   ```
* 是多余的，为了保证之前BUG修复多加的一句话忘了删除了。


**问题1: 咋一看代码，看似都明白，细细思量，似懂非懂，自己写起来，啥都忘了，满脑袋空白，一脸懵逼。不看一眼代码，或者三四五六眼，根本想不起来，该怎么改善？**
**程序的构建过程**
1. 咋一看代码，看似都明白 。 
   
- 代码不是用来让你看的，是用来让机器看的。
- 问一下自己每一行的思路来由你都清晰么 ? 不要说代码是什么 !  要说代码为什么 ! 
  
2. 自己写起来，啥都忘了，满脑袋空白，一脸懵逼

- 先思路再代码 
- 伪代码 

```javascript
      获取银河系所有生物 
      遍历所有银河系生物
      在遍历之中判定性别种类

      for(var i = 0 ; i < 银河系生物的数量; i++){
            switch(性别){
                  case 性别1 : 
                        归类;
                        break;
                  ...
            }
      }
```
```javascript
      // 核心
      // 1. 选择难度;
      // 2. 创建动画;
      // 3. 游戏开始;

      // 战机
      // 1. 跟随鼠标移动
      // 2. 开火

      // 子弹
      // 1. 创建定时器;
      // 2. 创建子弹列表;
      // 3. 子弹统一运动;
      // 4. 子弹销毁;

      // 敌机
      // 1. 创建定时器;
      // 2. 创建敌机列表;
      // 3. 敌机统一运动;
      // 4. 敌机销毁;

```


3. 不看一眼代码，或者三四五六眼，根本想不起来，该怎么改善

- 你想要和我写一样的代码不可能 ! 代码表述都有细微的差别。
- 你写 BUG 才是正常的。 在坑里跌倒了，才能真的在坑里站起来。 


**问题2:静态方法和属性可以在别的类中被使用,但是飞机大战核心部分里的创建元素函数只在Core类中使用,是出于什么原因设置成静态的呢?什么时候适合用静态方法和静态属性呢?**
* 为了教你们用这个东西。
* 在类之间进行耦合设计的时候。


**问题3: 飞机大战进入游戏前，飞机往右飞的加载图 怎么使用网络图片设置？**
* 用数组承载图片的路径，在飞的时候遍历数组就可以了;


**问题4: 智哥,js是基于对象而不是面向对象的这种说法该怎么理解?**
* 基于对象 => 原型链机制,这是JS面向对象编程的核心功能;
- 构造函数 ， 原型 ，实例
* 面向对象 => 严格意义上来说, JS不具备类 , 多态 。  
- 同一思想，不同问题解决方案。


**问题5: 智哥智哥，飞机大战游戏开始的时候，当我的飞机出来，如果不动鼠标的话他会一直在下面的中间发射子弹，能不能让飞机刚创建的时候就获取到鼠标的位置定位到鼠标上呢？**
* 初始定位;
* Core里面获取鼠标坐标;
```javascript
      // 在 Core 之中 ,获取当前鼠标的位置。

       createPlane(){
            let ele = document.createElement("div");
            let cWidth = document.documentElement.clientWidth;
            ele.className = "plane";
            ele.style.cursor = "none";
            document.body.appendChild(ele);
            ele.style.left = this.boundary(Core.mousePosition.x,Core.mousePosition.y,ele).x + "px";
            Plane.x = ele.offsetLeft;
            Plane.y = ele.offsetTop;
            return ele;
       }

       boundary(x,y,ele){
            let minX =  this.mainSize.left;
            let maxX =  this.mainSize.left + this.mainSize.width - (this.eleSize ? this.eleSize.width : ele.offsetWidth)  ;
            x = x < minX ? minX : x;
            x = x > maxX ? maxX : x;

            y = y < 0 ? 0 : y;
            return {
                  x ,
                  y 
            }
       }    

```


**问题6: 飞机大战缩小窗口后，飞机的位置会跑出背景的限定范围，该怎么解决？**
* resize 去改变窗口改变改变的值;


**问题7: MySQL创键数据库时，连接名是用来干嘛的？只是个单纯分组吗？**
![image.png](https://upload-images.jianshu.io/upload_images/2845301-bcccfe89f42d841d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
>* 你可能会链接很多的数据库, 用仓库名区分链接的是哪个数据库。


**问题8： 数据库遍历while循环中的=号怎么理解？ 感觉赋值 和 判断等于都不太像。**
```javascript
      $sql_select = "SELECT username FROM gptest";

      if($result = mysqli_query($conn,$sql_select)){
            // 查看存在多少条数据;
            // echo mysqli_num_rows($result);

            // 拿出每一条数据;
            while($row = mysqli_fetch_assoc($result)){
                  echo json_encode($row);
            }

      }else{
            echo mysqli_error($conn);
      };
```
* 赋值

- 如果说一个方法的返回值既要判断又要在后面编程之中进行使用，那么这个时候我们通常用一个小技巧来处理这样的问题;

* 基本模型
```javascript
      let a ; 
      if( a = foo() ){
            console.log(a);
      }
```


**问题 9： 下面出错的原因是什么呀？**
![image.png](https://upload-images.jianshu.io/upload_images/18300474-02d8c1e332ca968e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![image.png](https://upload-images.jianshu.io/upload_images/18300474-32e4337f948c8745.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* 语法  :  varchar(255) 


**问题10： 智哥,下图if判断只是判断语法是否成立而不能判断是否删除吧,就算我的表里没有数据,仍然会提示成功**

![image.png](https://upload-images.jianshu.io/upload_images/18300474-1ebc1b577c0775aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
* 删除操作不报错就挺好。


**问题11：智哥，有没有可以格式化php代码的插件，强迫症不优雅的代码有点难受。。**
* phpfmt 


**问题12：如果想要创建一个表名是纯数字的表，用sql语句如何实现。**
*  CREATE TABLE '1'( A , B , C ) VALUES ( 2, 3, 4)


**问题13：智哥，关于mysql语句中行的概念不是很清楚，以及SELECT语句中 * 和 where的用法**
   * 一条关联数据;    * 所有字段 ;  where 条件 name=女朋友|男朋友 ; 


**问题14：php 中 . 的语法, $str .="str" ,是表示 加号 吗**
   * 字符串 JS 之中的拼接 +  php 之中的字符串你拼接是 .
   * "高级字符串" , '常规字符串'
   * array(1,2,3,4,5,6); => JS之中的数组;
   * array('a' => 'b') ; => JS之中的对象;


**问题15： 可以一次给表添加(插入)多条数据(记录)吗？如果可以的话，该怎么添加呢？**
```mysql
      insert into 表 
      (字段 1 , 字段 2, 字段 3, 字段 4)
      values
      (200,'haha' , 'deng' , 'shenzhen'),
      (201,'haha2' , 'deng' , 'GD'),
      (202,'haha3' , 'deng' , 'Beijing');
```


#问题16:  php解析器位于什么地方,是和js解析器一样在浏览器里吗?还是在服务器里?
* 都不是
* PHP 是一个独立的环境。 
* 只不过 服务器碰到 .php 后缀的请求会调用 cgi 去使用php解析器解析代码;


**问题17: ajaxpost封装，报405不允许错误的原因，没理解， 老师源码在我本地换个路径也这样，而其他请求都正常。**
ajaxpost.html:41 POST http://localhost/0710/data.txt?data=1 405 (Not Allowed)
>post请求没法获取JSON数据


**问题18 请老师讲一下promise封装在ajax**
```javascript
     // IE8 + ;

            // type => GET | POST 
            // payload ; => form data ; key:value
            // url  => 
            // callback  干掉;
            // function ajax(  url , callback , data, type  ){
            //       // 如果type 为 get 那么data拼接在url上 
            //       // 如果type 为 post 1. 设置请求头  2. 把data放在send里; 
            //       var xhr = null;
            //       if(XMLHttpRequest){
            //             xhr = new XMLHttpRequest();
            //       }else{
            //             xhr = new ActiveXObject("Mricosoft.XMLHTTP");
            //       }
            //       if(xhr === null) throw "浏览器不支持ajax";

            //       xhr.open( type ? type : "GET" , url );
            //       type === "POST" ? xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded"): "";
            //       xhr.send( null );
            //       xhr.onreadystatechange = function(){
            //             if(xhr.readyState === 4 && xhr.status === 200){
            //                   callback(xhr.responseText);
            //             }
            //       }
            // }
            // ajax();

            // data版本剖析

            // function ajax(  url , callback , data, type  ){
            //       // data  key=value&key2=value2;
            //       //     => {key:value,key2:value2};
            //       var dataStr = "";
            //       for(var attr in data){
            //             dataStr += `${dataStr.length > 0 ? "&" : ""}${attr}=${data[attr]}`;
            //       }
            //       // GET 
            //       url += (/\?/.test(url) ? '&' : "?") + dataStr;
            //             // console.log(url);
            //       // POST 
            //       xhr.send(dataStr);
            // }
            // ajax("http://www.baidu.com",2, {key:"value",key2:"value2"});

            // 合并版;
            // function ajax(  url , callback , data, type  ){
            //       // 如果type 为 get 那么data拼接在url上 
            //       // 如果type 为 post 1. 设置请求头  2. 把data放在send里; 
            //       var xhr = null;
            //       if(XMLHttpRequest){
            //             xhr = new XMLHttpRequest();
            //       }else{
            //             xhr = new ActiveXObject("Mricosoft.XMLHTTP");
            //       }
            //       if(xhr === null) throw "浏览器不支持ajax";

            //       var dataStr = "";
            //       for(var attr in data){
            //             dataStr += (dataStr.length > 0 ? "&" : "") + attr + "=" + data[attr];
            //       }

            //       type === "GET" ? url += (/\?/.test(url) ? "&" : "?") + dataStr : "";

            //       xhr.open( type ? type : "GET" , url );
            //       type === "POST" ? xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded"): "";
            //       xhr.send( type === "POST" ? dataStr : null );
            //       xhr.onreadystatechange = function(){
            //             if(xhr.readyState === 4 && xhr.status === 200){
            //                   callback(xhr.responseText);
            //             }
            //       }
            // }


            // promise 封装之前要做的事;

            function ajax(url  , data, type){
                  return new Promise( function(resolve , reject){

                        var xhr = null;
                        if(XMLHttpRequest){
                              xhr = new XMLHttpRequest();
                        }else{
                              xhr = new ActiveXObject("Mricosoft.XMLHTTP");
                        }
                        if(xhr === null) throw "浏览器不支持ajax";

                        var dataStr = "";
                        for(var attr in data){
                              dataStr += (dataStr.length > 0 ? "&" : "") + attr + "=" + data[attr];
                        }

                        type === "GET" ? url += (/\?/.test(url) ? "&" : "?") + dataStr : "";

                        xhr.open( type ? type : "GET" , url );
                        type === "POST" ? xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded"): "";
                        xhr.send( type === "POST" ? dataStr : null );
                        xhr.onreadystatechange = function(){
                              if(xhr.readyState === 4 && xhr.status === 200){
                                    resolve(xhr.responseText);
                              }
                        }

                        // 设置超时;
                        setTimeout(function(){
                              reject(xhr,"timeout");
                        },8000)
                  })
            }

            ajax()
            .then()

```

**问题19：BUG**

```javascript
//04观察者模式的代码
// 移除订阅功能;
this.list = { 
    12 : [],
    18 : [],
    all: []
};  //  数据结构
unsubscribe(type,obs){ 
    this.list[type].splice(this.list[type].indexOf(obs),1);  
    //this.list是对象，不可以直接indexOf
}
>解决
// solution 
unsubscribe(obs){ 
    this.list["all"].splice(this.list["all"].indexOf(obs), 1);  // all中删除
    if(obs.age >= 12 && obj.age <= 18){
        this.list["12"].splice(this.list["12"].indexOf(obs), 1);// 12 中删除
    }else if(obj.age >= 18){
        this.list["18"].splice(this.list["18"].indexOf(obs), 1);// 18 中删除
    }
}

```


**问题20: 后台服务器可以获取前端传过去的key值吗？ 后台写的固定key值'callback'，那封装中的cb_fild是不是可以省略？**

* 什么是服务器 ? http服务 ;  nginx , apache , iis , nodejs , ...
```javascript
      http://www.baidu.com/v2/search?wd=hello&p=10#aaa
      协议  
             域名 
                          query(告知服务器路径)
                                     search(GET协议携带的数据) 
                                                   hash(前端用的页面传值)
```
* 解析数据 (字段值) 语言解析器来做的。
      协议携带的数据 > GET | POST 
* 后台写的固定key值'callback'，那封装中的cb_fild是不是可以省略
      可以这么操作但是不建议, 因为你的jsonp封装是面向所有使用场景的。
```php
<?php
      $cbname = $_GET['callback'];
      $data = "hello world";
      echo "$cbname('$data')";
?>
```
```javascript
function jsonp(url,cb_fild,callback){
      var GLOBAL_CB = "foo"
      // 1.全局函数;
      window[GLOBAL_CB] = function (res){
	//声明一个任意的全局函数,去调用我们需要调用的回调函数callback,该函数运行没有任何结果，只是用来传值
            callback(res)
      }
      // 2. 发送请求; 
      var script = document.createElement("script");
      url += /\?/.test(url) ? "&" : "?";
      script.src = url + cb_fild + "=" + GLOBAL_CB;
console.log(url + cb_fild + "=" + GLOBAL_CB);
      script.onload = function(){
            this.remove();
      }
      document.body.appendChild(script);
}
```


**问题21 能否通过传入具名函数，获取到它的函数名字符串，如果可以这样的话，是不是可以省去设置全局函数调用回调函数的步骤？**

* 高内聚 ， 低耦合 ;
* 严重耦合全局函数，封装的功能不独立。
  
```javascript
function trueCallback(res){
    console.log(22,res);
    console.log(arguments);
}
jsonpl("http://localhost/BaseServer/0711/jsonptruedata.php","trueCallback");

function jsonpl(url,calback){
    var script = document.createElement("script");
    url += /\?/.test(url) ? "&":"?";
    console.log(url);
    url = url + "fooname"+"="+calback;
    console.log(url);
    script.src = url;
    script.onload = function(){
        this.remove();
    }
    document.body.appendChild(script);
}
```

**问题22 promise连缀那里听得不太明白，具体是咋运用，请智哥再讲一下。**
```javascript
      let promise = new Promise( (resolve , reject) => {
            setTimeout( a => {
                  console.log(1);
                  resolve();
            },1000)
      })
      // promise Promise resolver 
      let promise2 = promise.then( res => {
            return new Promise( ( resolve , reject ) => {
                  setTimeout( a => {
                        console.log(2);
                        resolve();
                  },1000)
            })
      })
      // 返回值是一个新的状态机 ;
      promise2.then( res => {

      })
```

**问题23  实际开发中，如果是和后台联调，服务器不在本机时，使用ajax请求时，如何让本地代码和后台服务器同源**
 * nginx 

 
**问题24 劳烦智哥讲解一下这种 promise 连缀**

```javascript
function next(n) {
  return new Promise(function(resolve, reject) {
    setTimeout(function() {
      resolve(n);
    }, 1000);
  });
}
next(1) // promise1;
  .then(function(res) {
    console.log(res);
    return next(2); 
  })
  // promise2 ;
  .then(function(res) {
    console.log(res);
    return next(3);
  })
  .then(function(res) {
    console.log(res);
    return next(4);
  })
  .then(function(res) {
    console.log(res);
  });
```

**问题25 问题在图中，是一个小bug**
![image.png](https://upload-images.jianshu.io/upload_images/18300474-7af4628697d4862f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```javascript
    function foo(type){
        // type = type ? type : "GET";
        type || type = "GET" ;
    }
```
 

**问题26 接口到底指什么？接口地址是什么？**

* 接口其实就是返回数据的一个地址;
* 这个地址通常指向一个后端语言编写的文件;
* 接口是一个高级函数 => 传入参数 , 返回结果;


**问题27 ajax和jsonp的区别与联系。**
* AJAX => 异步 的 JavaScript 和 XML;

* 包含了 各种各样的请求;
      1. XHR 发起请求;  一个受同源策略但是浏览器原生支持的可以发送请求的对象。
      2. jsonp 利用script标签发起请求; 利用一个非官方提供的方式利用官方规则的漏洞发起请求的方式。


**问题28 onreadystatechange事件处理函数中使用了xhr对象，那可以使用this吗？**
      * 试一试 ; 
 
  ``` javascript
      this === xhr  // true;
      xhr.onreadystatechange = function(){
            this  === xhr 
      }     
  ```

**问题29 网站上哪些是可以通过JSONP获取的数据？**
* 观察接口返回的数据类型;

```javascript
      foo({})
```
* 携带发送数据的时候 存在  cb || callback 这样字段的接口也大概率是jsonp;


**问题30  智哥 能讲下TOKEN 与cookie 的关系，domain与path 的关系吗?**
* token => 一种字符串加密和构成规范。 就是把 对象 里面的数据进行编码 。
> 证明你登陆了, 携带一些特殊的信息。

* cookie => 是一种浏览器端的本地存储技术。我们可以利用http去进行设置;
> 我们把token存在cookie之中。

* domain 域 !  http://*www.baidu.com*
* path   路径  http://www.baidu.com*/error/page/1*


**问题31  免登陆案例中，为什么修改了utils里面的代码，但在浏览器控制台sources里面，还是之前的utils代码，重启浏览器和服务器都一样，电脑重启后代码正常，是浏览器缓存原因吗？该怎么处理？**
* 就是浏览器缓存 : 外联的文件都会缓存; 
* 两次请求同一路径( js , css ) ; 
* 解决方案 : 我们让浏览器感觉不一样就行了 http://www.baidu.com/script.js?_时间戳 可以避免缓存;
* 手动清除缓存 ctrl + shift + delete 


**问题32 如下图,图片里框柱的东西导致请求发不出去**
![123.png](https://upload-images.jianshu.io/upload_images/18300474-00b5055d08e9d695.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
* 考虑代码问题 ;   浏览器是对协议进行了完整封装，你可以进行配置但是普遍不需要。 在遇到发送问题的时候，优先考虑代码层面再去考虑协议层面。




**问题1  使用代理跨域和CORS跨域都必须在服务器上运行吗？**

* 代理跨域 => 利用服务器帮我发请求。
* CORS跨域 => 请求服务器，服务器给相应，http头部加入特殊允许标识。

> 服务器其实给我们的提供的是一个 http 服务。

* jsonp 无论你在本地环境还是服务器环境 , src 可以无条件发起http请求。 
tip : 你写的所有的前端程序很少很少很少直接在本地跑。


**问题2  解决瀑布流bug时，sort()图片排版方法是在屏幕宽度改变方法执行之前的，是必须在changeContainerWidth方法中重新调用sort方法吗？可不可以省略sort方法调用？**
* 不可以;
```javascript
//宽度改变
changeContainerWidth(){
      let cWidth = document.documentElement.clientWidth;
      this.count = parseInt(cWidth / 250);//每行显示图片数
      console.log(this.count);
      //     图片父节点宽度改变
      this.container.style.width = this.count * 250 + "px";  
      // //重新排序
       this.sort();
}
```


**问题3 请智哥捋一遍分页的封装的js**

* 获取数据
   * 服务器代理跨域获取数据(反向代理) => nginx;    
   * 数据存放在实例之中供后续使用。
* 渲染页面
   * 渲染部分的裁切;
      - 页码  1
      - 当前显示多少; 5;
      计算 => 应有的下标;
      0 ~ 4
      5 ~ 9
      10~ 14
* 事件委托;
    * 点击获取下标;
    * 利用下标设置页码重新渲染;


**问题4 智哥，phpstudy服务器启动不了，卸载了重装也不行**。

* 重启下电脑试试;
* 断点五分钟试试;
* 重装个系统试试;

  1.端口被占用; 
  2. 配置写错了; 
  3. 记得查看错误日期 ; nginx/log/error.txt


**问题5  jQuery选择器设置css属性不受权重影响，只根据就近原则来设置样式吗？**
* 这是JS设置样式啊 => 行内样式 => 覆盖形设置没有权重关系。只和执行顺序有关。


**问题6 详细讲一下函数节流和函数去抖。**

* 函数节流  执行频率降低; 

- for 循环执行时长300ms  3000000 次程序执行 ;
- 如果函数执行则要执行3000000次运算。 有多少是必要运算 ? 
- 60 fps => 16.66ms 刷新一次;
- 100ms 执行一次;

```javascript

      // 高频执行函数 => foo
      function foo(){
            // 刷新页面;
      }
      // 定时器执行频率不变;
      setInterval( foo , 1 );
      // 做一个函数的预处理;

      function foo(){

      }

      // 函数节流 ;

      // 基本结构不好用;
      // var timer = null;
      // function throttle(cb){
      //       // 只要没达到标准,就不执行foo函数;
      //       setTimeout( cb , 16 )
      // }

      function throttle( foo , delay){ // fn2 
            var timer = null;
            return function(){ // 
                  if(timer !== null) return false;
                  timer = setTimeout( ()=>{
                        foo()
                        timer = null;
                  } , delay )
            }
      }
      setInterval( throttle(foo , 16) )
```

* 函数去抖 

无论你执行多少次,我都在最后一次执行延时n ms之后执行。

```javascript
      // 函数高频次执行 持续5s ，实际我需要的渲染次数只有一次;
      function foo(){}
      let timer = setInterval( foo , 1 );
      setTimeout(()=> {
            clearInterval(timer)
      } , 5000)

      // 如果在一定时间之内还有下一次执行, 那么取消本次执行;
      function debounce( cb , delay ){
            let timer = null;
            return function(){
                  clearInterval(timer);
                  timer = setInterval(()=> {
                        cb();
                  },delay)
            }
      }

      //更新;
      function foo(){}
      let timer = setInterval( debounce( foo , 200 ) , 1 );
      setTimeout(()=> {
            clearInterval(timer)
      } , 5000)
```

##问题7 jQuery如何加载字符串模板数据，下面html和text方法都不行，是用错方法了吗？
```javascript
    // 渲染按钮;
    let html = "";
    for(var i = 0 ; i < total ; i ++){
          if(i + 1 === this.pageNo) {
                html += "<span class=active>${i+1}</span>";
          }else{
                html += "<span>${i+1}</span>";
          }
    }
    this.page_wrapper.html(html)//??????
    //一定一定多看文档 , 我不是文档。
```


**问题8  ## 千锋教师团队最靓的智仔，在jQuery库中，我不是很理解这里传入的window。**
```javascript
      (function(window) {
            window.jQuery
      //...

      })(window);
```
* 用于节省性能 , 因为jQuery插件之中大量存在jQuery变量的引用，所以传入window可以让解释器少找寻一次作用域。


**问题9  能不能给咱整整这句话的意思**
```javascript
      jQuery.extend = jQuery.fn.extend = function(){
      //.....
      }
      // 
```

* 给两个属性进行赋值赋值为同一个函数。
* extend 方法 期中有一个功能 直接向构造函数或原型合并对象。
* 就是在这个函数调用的时候想要有两种this;
```
      $.xxx    this => 构造函数;
      $().xxx; this => 实例对象;
```


**问题10 怀智小哥哥，把jQueryajax的type改为post后报如下错误该怎么解决呢？**
![image.png](https://upload-images.jianshu.io/upload_images/18464133-0ec266ea2769c163.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
```javascript
    $.ajax({
            url: "practice06.json",
            type: "POST"
        })
```
* 用合适的方法去做合适的事情。 
* 服务器配置问题


**问题11  购物车最后的事件监听没懂，没太理解添加监听方法中传入type，"changeNum"的作用是什么？**

*  因为在更新 localStorage 数据的时候 , 要同时跟新视图。
   
    更新购物车视图功能在 index.js  模块之中
    更新数据的功能在     carts.js  模块之中 
    
    耦合无法处理;   跨模块;  
    模块的实例对象上添加一个属性;
    设计模式 : 观察者模式 ;

    carts 模块添加了订阅和发布功能;
    
    订阅者 : 购物车视图更新功能;
    发布者 : carts内部的事件  ;


**问题12 智哥，这个地方这个type是干嘛的呀**
![image.png](https://upload-images.jianshu.io/upload_images/18300474-f161f2a7fe2b1f03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* 为啥非得加 type ?  
  
  以后有没有可能再多加一个功能，更新列表。
  对以后可能增加的功能进行合理的划分做准备。
  存数据 , 需要取出数据的时候。


**问题13  智哥，对模块化的概念不是很清楚，能再理一遍嘛？**

* 为什么  :  因为浏览器随缘加载JS导致JS执行顺序不可控,因为咱们编写的JS可能依赖非常多的插件。 只能用一个可靠的加载方式进行加载。 于是require.js 出现了;

* 是什么  :  一个JS加载器 。 但是因为JS的特征 , 引入script之后就会立即执行JS代码 。 于是requirejs就给使用者定义了一套规范 。 AMD 。  require | define

* 怎么用  :  利用 deinfe 定义模块, 利用 require 加载模块。 


* 注意事项 : 依赖 ， 耦合;

            依赖处理原则 : 使用之前进行加载, 依赖前置。
            耦合关系     : 以前都是以类以方法进行划分的随着程序的复杂度变得更大，我们需要以模块的形式对程序进行耦合关系处理。 
            让我们不仅可以进行优秀的耦合关系处理，更可以在开发过程之中高效高速定位需要更新的js文件。
            

**问题14 智哥，为什么用livesever运行你的购物车代码，ajax请求返回的数据是对象，用自己的服务器返回的是字符串。**
![image.png](https://upload-images.jianshu.io/upload_images/18464133-c087f1a73c1c51c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![image.png](https://upload-images.jianshu.io/upload_images/18464133-31b9bf88b2ea7168.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* liveserver版本问题, 需要在 $.ajax 里面加上 dataType 。


**问题15 再讲讲requireJS**

> 疑问：我看到有几个js文件里的define数组虽然写上了”jquery“，但是并没有在后面的function上对应的位置写上参数, 是忘记写了还是这种存在链式引用关系不需要重新在调用jquery.js等之前已经调用过得js文件

```javascript
// carts.js

window.$ = window.jQuery = function(){

}
return window.jQuery ;

define(['jquery',], function($) {
    'use strict';
    .....
}
       
// render.js
define(['jquery',"./loaddata"], function() {
      'use strict';
    .....
}
```

* 根据jQuery的代码我们了解到只要jQuery被加载了 那么就会在全局创建一个 jQuery 构造函数的引用 即 $;
* jQuery 也遵从AMD规范 在程序的末尾 返回了 $ , jQuery ;


**问题16 需要讲一下ES6模块化拆分案例，ES6模块化需要在标签<script type="module"></script>里面引入，所有耦合处理得放到HTML文件里面吗？**

* 购物车
* 所有耦合处理得放到HTML文件里面吗 => 不一定 , index 业务逻辑模块; 


**问题17 购物车的cart模块，在减少购物车中商品数量时，使用jQuery的each会报错，循环会进行到已被删除的项的下标那，导致取到undefined；而使用forEach不会报错,请问智哥这是为什么呢？**
![image.png](https://upload-images.jianshu.io/upload_images/18464133-e92e19ebc9b2ab56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![image.png](https://upload-images.jianshu.io/upload_images/18464133-b60542cb01b1413c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* forEach 的原理大概是  
```javascript
      for(var i = 0 ,item ;  item = arr[i++] ; ){

      }
```
如果取出来的值是 undefined 压根不执行循环;

* $.each 
```javascript
      var len = arr.length; 
      for(var i = 0 ; i < len ; i++){

      }
```
在$.each 之中增删数组都可能会导致循环内部出现问题。
-解决方案 : 报错是因为item是undefined 所以判定 if(item === undefined) return ;


**问题18 智哥 ， 帮忙分析一下上面代码**
```javascript
class A {
  constructor() {
    // this.x = 1;
  }

  get x(){
    console.log("x get");
  }
}


class B extends A {
  constructor() {

  }
}

let b = new B();
```



* super()        => 父类.call(this) 对象的一个继承;
* super.prop     => 父类上的属性;  父级原型上的属性 prop ;
  - super.prop = xxx ;  此时super指向 this; 子类;
  - super.prop       ;  此时super指向 父类.prototype.属性;
1. 构造函数 A ; 
   this.x  ; 加工实例对象,添加x属性;
   A.prototype 里面啥都没有空空如也;
   
2. 构造函数 B ; 
   B extends A;
   super(); // B的实例对象放入A的constructor之中进行加工 ; B{x : 1}  
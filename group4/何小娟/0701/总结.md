#问题


#运动框架
原因：
  1.原因：两次调用函数会覆盖；
解决：
  1.参数以对象的形式传入；

#异步
  使用是异步的函数/方法那它本事就是异步；
  回调函数只在异步中有

#面向对象
##目标：
  解决问题（规模够大，协作够精密）的方案
##原因：
  不会因为一个环节破坏掉就整个垮掉；
##解决：
  分工目标；
##OO编程（面向对象编程）的步骤
  1.OOA ：分析
  2.OOD ：设计
  3.OOP ：编程
##理解：
  集合对内容进行一个关联
  集合其实本质就是设计耦合关系，不同参数

##过程：
  拆分功能，最终整合在一起
  
##数据分析
  1.数组：遍历查找某项内容
  2.对象：通过key值精准快速拿到数据
##如何把程序放在对象上
  1.创建一个对象；
  2.给对象添加属性；
##工厂模式（区分设计模式的根据：导向（目的性））
  解决了重复创建对象的麻烦；
  但是JS自带工厂模式，构造函数就是天生的工厂模式
##构造函数（new 出来的函数）
  目的：批量构造对象
      1.创建一个对象，也就是实例，本质上是一个空对象； *  //构造函数开头
      2.编程；
      3.出场；结尾偷偷返回这个实例                    *  //构造函数结尾
      带*的构造函数默认已经实现了；
  每次调用构造函数都会创建一个新对象
##构造函数的指针this无条件的指向构造函数的实例
  作用：访问实例并对实例编程
##解决对象的浪费
解决：
  原型：Foo.prototype


#构造函数、原型、实例三者的关系
1.构造函数与原型的关系
  任何函数在创建的时候都有一个伴生对象（一直都在，没注意过），这个伴生对象叫原型（可供储存数据的空对象）
  原型里面有：
    1.构造函数指针
    2.原型指针：Object的顶层对象
    构造函数与原型的关系 ： FOO.prototype
2.构造函数与实例的关系
  1.new出来的是实例，构造函数可以new很多实例；
  2.实例没有名字，谷歌控制台上把构造函数的名字作为实例的名字，实属谷歌优化用户体验的操作，与JS无关；
3.实例与原型的关系
  实例里的原型指针：_proto_，指向当前构造函数的指针；
  **实例可以访问原型中的属性和方法**
  **原型链与作用于链一样：先从当前找，找不大向外找**

IE5+都兼容：

总结：编程时构造函数放属性，原型对象放方法


#选项卡
1.耦合关系就是调用关系；
2.给原型对象上添加方法；
  原型里方法的this指向大多数是实例，如果不是实例，把this转向实例；
  bind，call，apply改变this指向到实例；bind最常用；
3.原型怎么访问实例里的属性？
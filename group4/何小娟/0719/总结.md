###ES6module(模块化规范)
    都是异步的；
    特征：原生支持，可以配套使用   const | let | class
    1.import 导入  AMD => reqire 加载模块
    2.export 导出  AMD => define 定义模块
    注意：不会应用到实际的项目中，会把它当做构建项目的过程，不会把ES6模块化当做加载的工具，当做程序分割的工具，在本地进行分割，在开发过程之中分割，然后打包，合并成一个文件，上线；

    支持：web端(高级的Chrome) | webpack(工程化构建工具：打包，但是配置很麻烦,不学) | gulp(工程化构建工具：压缩代码)

    注意：
        1.用live server打开；
        2.import的内容必须是符合模块定义的模块(js文件)，不符合就报错；
        3.引入是对象，放在{}里面。比如$;
        4.export default{} :里面返回唯一的对象；
            多个对象返回
            1.把其他对象放在一个对象里，再返回这个大对象；
            2.export + 返回的内容；
                export let a = {name：hxj}
            弊端：要知道引入对象a的名称，必须使用解构得到对象a
            3.import * as module from "./XX":
                module变成了一个包含其他所有对象的大对象；
        5.export + 各种的声明方式
            1.export let
            2.export const
                这里的常量不可更改
                想要更改的话：

        6.导出解构
            1.
        7.导出解构并重命名
        8.export可以加载别人的依赖
            ./XXX是另外一个export导出js文件
            export {name} from "./XXX"
            ./XX是上面的export导出的js文件
            import {name} form "./XX"


###继承
    原理：继承别的方法来自己使用;
    条件：构造函数，面向对象编程(构造函数，原型，实例)；
    1.ES5继承
        1.对象克隆；
        call()、apply()

        2.原型链继承；

    2.ES6继承
        1.extends;
        2.super();





###DOM的知识
回流：offset、增删改查
重绘：重新渲染、决定定位
优化：SEO、DOM、

作业:改写瀑布流和分页；


###模式总结
    1.单例模式；
    目标：无论多少次实例，只创建一个实例对象；
    原理：构造函数只要有返回的对象，就不会返回原来的实例对象；
    2.观察者模式；
    目标：一对多的对象处理方案，异步的解决方案；
    3.工厂模式；
    4.责任链模式；
    目标：区分耦合关系设计
    5.代理模式；
    目标：接口的复用，适配。
    6.策略模式；
    目标：方便功能的
    7.装饰者模式；
    8.MVC模式；
    9.MVVM模式；
    10.组合模式；

    区分模式以目标为导向，不以代码为导向；



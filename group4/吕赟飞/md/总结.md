# 事件

1. **事件流,事件执行顺序**
      * 事件流 : 其实就是事件传播的过程。
      * 事件的触发阶段
      ![事件触发流程图MDN.png](https://upload-images.jianshu.io/upload_images/16960494-0fb99c1d4d622be6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
            1. 捕获阶段
            2. 目标阶段
            3. 冒泡阶段
      * 三个阶段分成两种情况 : 
            1. IE       : 先目标再冒泡
            2. netspace : 先捕获再目标;

2. **事件监听**
      * 什么是监听 ? 和onclick有啥区别。
      * 是在捕获阶段或者冒泡阶段添加侦听方法的一个工具。
      * addEventListener( 事件名 , 事件处理函数 , boolean[ 捕获 | 冒泡 ] ); 
      * removeEventListener(  事件名 , 事件处理函数 ) ; 
      * --封装 ; on , off;

3. **阻止事件冒泡**

      * stopPropagation(); 

```javascript
       typeof e.stopPropagation === "function" ? e.stopPropagation() : e.cancelBubble = true;
```

4. **拖拽**

      * 鼠标按下 => 拖拽开始;
```javascript
      // 获取offset值;
      e.offsetX 
      e.offsetY 
```
      * 鼠标移动 => 拖拽进行;
      * 鼠标抬起 => 拖拽结束;

5. **bind , call , apply**

      **功能**
      * bind  => 在声明阶段*固定*函数的this指向.
      * call  => 在调用阶段*改变*函数的this指向.
      * apply => 在调用阶段*改变*函数的this指向.

      **参数**

      * call   => call  在第二个参数之后的所有实参和形参一一对应 
      * apply  => apply 第二个参数和arguments向对应。

6. 柯里化 
      
      **总结:** 函数嵌套，函数替函数进行调用。

```javascript
      var curry = function(fn){
            return function(){
                  fn.call({key:"value"})
            }
      };
```
      **bind**方法的实现;

```javascript
      // 1. bind会返回一个新函数;
      // 2. bind之后的函数this指向永不更改。
      function myBind(fn,_this){
            return function fnCaller(){
                  fn.call(_this)
            }
      }
```

7. 拖拽的实际项目应用

8. 默认事件

      * 图片拖拽
      * 右键弹出框
      * 表单跳转
      * a标签跳转
      * input 输入内容
      * checkbox选择内容
      * 文字选中
      * ...

      **阻止默认事件**

```javascript
      typeof e.preventDefault === "function" ? e.preventDefault() : e.returnValue = false; 
```
9.  自定义右键菜单案例

